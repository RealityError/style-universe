<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>é£æ ¼å®‡å®™ Â· Style Universe</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Noto+Sans+SC:wght@300;400;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --accent: #7c5cff;
      --accent2: #35d1ff;
      --bg: #050508;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      overflow: hidden;
      background: var(--bg);
      font-family: 'Noto Sans SC', sans-serif;
      color: #fff;
    }
    #canvas { position: fixed; inset: 0; z-index: 0; }

    /* UIå±‚ */
    #ui {
      position: fixed; inset: 0; z-index: 10;
      pointer-events: none;
      display: flex; flex-direction: column;
      align-items: center; justify-content: flex-end;
      padding-bottom: 40px;
    }
    #ui > * { pointer-events: auto; }

    /* è¿”å›æŒ‰é’® */
    #back {
      position: fixed; top: 20px; left: 20px;
      padding: 12px 20px;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      color: #fff;
      text-decoration: none;
      font-size: 14px;
      transition: all 0.3s;
      z-index: 100;
    }
    #back:hover { background: rgba(255,255,255,0.1); transform: translateX(-3px); }

    /* ç»Ÿè®¡ */
    #stats {
      position: fixed; top: 20px; right: 20px;
      text-align: right;
      font-size: 12px;
      color: rgba(255,255,255,0.4);
      z-index: 100;
    }
    #stats .count {
      font-size: 36px;
      font-weight: 900;
      font-family: 'Orbitron', sans-serif;
      color: #fff;
      text-shadow: 0 0 30px var(--accent);
    }
    #stats .collected {
      margin-top: 8px;
      font-size: 11px;
    }

    /* å†å²æ”¶è— */
    #collection {
      position: fixed;
      left: 15px;
      top: 80px;
      bottom: 80px;
      width: 50px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      overflow-y: auto;
      padding: 5px;
      z-index: 100;
    }
    #collection::-webkit-scrollbar { width: 3px; }
    #collection::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
    .collection-item {
      width: 40px; height: 40px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      transition: all 0.3s;
      background: rgba(0,0,0,0.5);
      border: 2px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(5px);
    }
    .collection-item:hover {
      transform: scale(1.15);
      box-shadow: 0 0 20px var(--accent);
    }
    .collection-item.ssr { border-color: #ffd700; box-shadow: 0 0 15px #ffd70050; }
    .collection-item.sr { border-color: #a855f7; box-shadow: 0 0 10px #a855f750; }

    /* æŠ½å¡æŒ‰é’® */
    #pull-btn {
      padding: 20px 70px;
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 4px;
      color: #fff;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow:
        0 0 40px var(--accent),
        0 0 80px var(--accent),
        0 5px 30px rgba(0,0,0,0.5);
      transition: all 0.3s;
      text-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    #pull-btn:hover {
      transform: scale(1.05);
      box-shadow:
        0 0 60px var(--accent),
        0 0 120px var(--accent),
        0 5px 40px rgba(0,0,0,0.5);
    }
    #pull-btn.hidden {
      opacity: 0;
      pointer-events: none;
      transform: scale(0.8);
    }

    /* å¡ç‰Œå±•ç¤ºé¢æ¿ */
    #card-panel {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
      z-index: 50;
    }
    #card-panel.show {
      opacity: 1;
      pointer-events: auto;
    }
    .card-container {
      perspective: 1500px;
    }
    .card {
      width: 300px;
      height: 420px;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .card.flipped { transform: rotateY(180deg); }
    .card-face {
      position: absolute;
      inset: 0;
      backface-visibility: hidden;
      border-radius: 20px;
      overflow: hidden;
    }
    .card-back {
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 3px solid rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 60px;
    }
    .card-back::before {
      content: '';
      position: absolute;
      inset: 10px;
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 15px;
    }
    .card-front {
      transform: rotateY(180deg);
      background: linear-gradient(180deg, var(--bg) 0%, #0a0a15 100%);
      border: 3px solid var(--accent);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 25px;
      box-shadow: 0 0 40px var(--accent), inset 0 0 60px rgba(0,0,0,0.5);
    }
    .card-front.ssr {
      border-color: #ffd700;
      box-shadow: 0 0 60px #ffd700, 0 0 120px #ff6b0080, inset 0 0 60px rgba(255,200,0,0.1);
    }
    .card-front.sr {
      border-color: #a855f7;
      box-shadow: 0 0 50px #a855f7, inset 0 0 60px rgba(168,85,247,0.1);
    }
    .card-rarity {
      padding: 6px 20px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 3px;
      margin-bottom: 15px;
    }
    .card-rarity.ssr {
      background: linear-gradient(90deg, #ffd700, #ff6b00);
      color: #000;
      animation: ssrPulse 1.5s ease-in-out infinite;
    }
    .card-rarity.sr { background: linear-gradient(90deg, #c084fc, #a855f7); }
    .card-rarity.r { background: linear-gradient(90deg, #60a5fa, #3b82f6); }
    .card-rarity.n { background: rgba(255,255,255,0.15); }
    @keyframes ssrPulse {
      0%, 100% { box-shadow: 0 0 20px #ffd700; }
      50% { box-shadow: 0 0 40px #ff6b00, 0 0 60px #ffd700; }
    }
    .card-icon {
      font-size: 80px;
      margin: 20px 0;
      filter: drop-shadow(0 0 20px var(--accent));
    }
    .card-name {
      font-size: 28px;
      font-weight: 900;
      text-align: center;
      text-shadow: 0 0 20px var(--accent);
      margin-bottom: 5px;
    }
    .card-name-cn {
      font-size: 16px;
      opacity: 0.7;
      margin-bottom: 15px;
    }
    .card-desc {
      font-size: 13px;
      text-align: center;
      opacity: 0.6;
      line-height: 1.6;
      padding: 0 10px;
      flex: 1;
    }
    .card-tags {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: auto;
    }
    .card-tag {
      padding: 4px 12px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 15px;
      font-size: 11px;
    }

    /* ç»§ç»­æŒ‰é’® */
    #continue-btn {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      padding: 16px 50px;
      font-size: 16px;
      font-weight: 700;
      color: #fff;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      border: none;
      border-radius: 30px;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s;
      box-shadow: 0 0 30px var(--accent);
      z-index: 60;
    }
    #continue-btn.show {
      opacity: 1;
      pointer-events: auto;
    }
    #continue-btn:hover {
      transform: translateX(-50%) scale(1.05);
    }

    /* å½“å‰é£æ ¼åç§° */
    #current-style {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 20px;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      font-size: 13px;
      color: rgba(255,255,255,0.5);
      opacity: 0;
      transition: opacity 0.5s;
      z-index: 100;
    }
    #current-style.show { opacity: 1; }

    /* æç¤ºæ–‡å­— */
    #hint {
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: rgba(255,255,255,0.2);
      letter-spacing: 3px;
      transition: opacity 0.5s;
    }
    #hint.hidden { opacity: 0; }

    /* é—ªå…‰æ•ˆæœ */
    #flash {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at center, var(--accent) 0%, transparent 70%);
      opacity: 0;
      pointer-events: none;
      z-index: 40;
      transition: opacity 0.2s;
    }
    #flash.ssr { background: radial-gradient(circle at center, #ffd700 0%, #ff6b00 30%, transparent 70%); }
    #flash.sr { background: radial-gradient(circle at center, #a855f7 0%, #7c3aed 30%, transparent 70%); }
    #flash.show { opacity: 0.6; }

    /* é£æ ¼æ€»æ•° */
    #total-info {
      position: fixed;
      bottom: 15px;
      right: 20px;
      font-size: 11px;
      color: rgba(255,255,255,0.25);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="flash"></div>

  <a id="back" href="index.html">â† è¿”å› 2D</a>

  <div id="stats">
    <div class="count" id="pull-count">0</div>
    <div>æ¬¡æŠ½å–</div>
    <div class="collected">å·²æ”¶é›† <span id="collected-count">0</span> / <span id="total-styles">0</span></div>
  </div>

  <div id="collection"></div>

  <div id="current-style"></div>

  <div id="hint">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹æ¢ç´¢é£æ ¼å®‡å®™</div>

  <div id="ui">
    <button id="pull-btn">âœ¦ æŠ½ å– âœ¦</button>
  </div>

  <div id="card-panel">
    <div class="card-container">
      <div class="card" id="card">
        <div class="card-face card-back">âœ¦</div>
        <div class="card-face card-front" id="card-front">
          <div class="card-rarity" id="card-rarity">SSR</div>
          <div class="card-icon" id="card-icon">ğŸ’</div>
          <div class="card-name" id="card-name">Glassmorphism</div>
          <div class="card-name-cn" id="card-name-cn">ç»ç’ƒæ‹Ÿæ€</div>
          <div class="card-desc" id="card-desc">æè¿°</div>
          <div class="card-tags" id="card-tags"></div>
        </div>
      </div>
    </div>
  </div>

  <button id="continue-btn">ç»§ ç»­ æ¢ ç´¢</button>

  <div id="total-info"></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    // ==================== å†…è” Shader ç³»ç»Ÿ ====================

    // ç¼“åŠ¨å‡½æ•°
    const Ease = {
      breathe(t, speed = 1) { return (Math.sin(t * speed) + 1) / 2; },
      bounceOut(t) {
        if (t < 1/2.75) return 7.5625*t*t;
        if (t < 2/2.75) { t-=1.5/2.75; return 7.5625*t*t+0.75; }
        if (t < 2.5/2.75) { t-=2.25/2.75; return 7.5625*t*t+0.9375; }
        t-=2.625/2.75; return 7.5625*t*t+0.984375;
      },
    };

    // å™ªå£° GLSL
    const noiseGLSL = `
      vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}
      vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
      vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
      vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
      float snoise(vec3 v){
        const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);
        vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);
        vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;
        vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);
        vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;
        i=mod289(i);
        vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
        float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;
        vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);
        vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);
        vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);
        vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;
        vec4 sh=-step(h,vec4(0.0));
        vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
        vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);
        vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
        p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;
        vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;
        return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
      }
    `;

    // Shader æè´¨å·¥å‚
    function createFluidMat(c1, c2, opts={}) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uColor1:{value:new THREE.Color(c1)}, uColor2:{value:new THREE.Color(c2)}, uNS:{value:opts.ns||1.5}, uSpd:{value:opts.spd||0.4}, uDef:{value:opts.def||0.8}, uOp:{value:opts.op||0.7} },
        vertexShader: `uniform float uTime,uNS,uSpd,uDef;varying vec3 vN,vP;varying float vD;${noiseGLSL}
          void main(){vN=normal;vP=position;float n=snoise(position*uNS+uTime*uSpd);vD=n;gl_Position=projectionMatrix*modelViewMatrix*vec4(position+normal*n*uDef,1.0);}`,
        fragmentShader: `uniform vec3 uColor1,uColor2;uniform float uTime,uOp;varying vec3 vN,vP;varying float vD;
          void main(){vec3 l=normalize(vec3(1,1,1));float d=max(dot(vN,l),0.0)*0.6+0.4;float f=pow(1.0-max(dot(vN,vec3(0,0,1)),0.0),2.0);vec3 c=mix(uColor1,uColor2,vD*0.5+0.5)*d;c+=f*uColor2*0.5;gl_FragColor=vec4(c,uOp);}`,
        transparent:true, side:THREE.DoubleSide
      });
    }
    function createGlowMat(c1, c2, opts={}) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uColor1:{value:new THREE.Color(c1)}, uColor2:{value:new THREE.Color(c2)}, uPS:{value:opts.ps||2}, uGI:{value:opts.gi||1.5} },
        vertexShader: `varying vec3 vN,vW;void main(){vN=normalize(normalMatrix*normal);vW=(modelMatrix*vec4(position,1.0)).xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader: `uniform float uTime,uPS,uGI;uniform vec3 uColor1,uColor2;varying vec3 vN,vW;
          void main(){vec3 v=normalize(cameraPosition-vW);float f=pow(1.0-max(dot(vN,v),0.0),3.0);float p=sin(uTime*uPS)*0.3+0.7;vec3 c=mix(uColor1,uColor2,f);float g=f*uGI*p;gl_FragColor=vec4(c*(1.0+g),0.6+f*0.4);}`,
        transparent:true
      });
    }
    function createAuroraMat(c1, c2) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uColor1:{value:new THREE.Color(c1)}, uColor2:{value:new THREE.Color(c2)} },
        vertexShader: `uniform float uTime;varying vec2 vUv;varying float vE;${noiseGLSL}
          void main(){vUv=uv;vec3 p=position;float n=snoise(vec3(p.x*0.05,p.y*0.1,uTime*0.3))*3.0;p.z+=n;vE=n;gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);}`,
        fragmentShader: `uniform vec3 uColor1,uColor2;uniform float uTime;varying vec2 vUv;varying float vE;
          void main(){vec3 c=mix(uColor1,uColor2,vUv.x+sin(uTime+vUv.y*3.0)*0.3);float a=0.15+0.1*sin(vUv.x*10.0+uTime);a*=smoothstep(0.0,0.3,vUv.y)*smoothstep(1.0,0.7,vUv.y);gl_FragColor=vec4(c*1.5,a);}`,
        transparent:true, side:THREE.DoubleSide, depthWrite:false
      });
    }
    function createHoloMat(opts={}) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uOp:{value:opts.op||0.6} },
        vertexShader: `varying vec3 vN,vW;void main(){vN=normalize(normalMatrix*normal);vW=(modelMatrix*vec4(position,1.0)).xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader: `uniform float uTime,uOp;varying vec3 vN,vW;
          void main(){vec3 v=normalize(cameraPosition-vW);float f=pow(1.0-max(dot(vN,v),0.0),2.0);float a=dot(vN,v);vec3 r;r.r=0.5+0.5*sin(a*6.28+uTime*2.0);r.g=0.5+0.5*sin(a*6.28+uTime*2.0+2.094);r.b=0.5+0.5*sin(a*6.28+uTime*2.0+4.189);gl_FragColor=vec4(r*(0.8+f*1.2),uOp+f*0.3);}`,
        transparent:true
      });
    }
    function createGlitchMat(c1, c2, opts={}) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uColor1:{value:new THREE.Color(c1)}, uColor2:{value:new THREE.Color(c2)}, uI:{value:opts.i||0.5} },
        vertexShader: `uniform float uTime,uI;varying vec2 vUv;varying vec3 vP;
          void main(){vUv=uv;vP=position;vec3 p=position;float g=step(0.95,fract(sin(floor(uTime*20.0)*43758.5453)))*uI;p.x+=g*sin(p.y*10.0+uTime*50.0)*2.0;gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);}`,
        fragmentShader: `uniform float uTime;uniform vec3 uColor1,uColor2;uniform float uI;varying vec2 vUv;varying vec3 vP;
          void main(){float s=sin(vP.y*50.0+uTime*10.0)*0.1;float r=step(0.97,fract(sin(floor(uTime*15.0+vP.y)*12345.6789)))*uI;vec3 c;c.r=mix(uColor1.r,uColor2.r,vUv.x+r);c.g=mix(uColor1.g,uColor2.g,vUv.x);c.b=mix(uColor1.b,uColor2.b,vUv.x-r);c+=s;gl_FragColor=vec4(c,0.8);}`,
        transparent:true, side:THREE.DoubleSide
      });
    }
    function createWaterMat(c1, c2) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uColor1:{value:new THREE.Color(c1)}, uColor2:{value:new THREE.Color(c2)} },
        vertexShader: `uniform float uTime;varying vec2 vUv;varying float vE;${noiseGLSL}
          void main(){vUv=uv;vec3 p=position;p.z+=sin(p.x*0.3+uTime)*1.5+sin(p.y*0.2+uTime*0.7)+snoise(vec3(p.xy*0.1,uTime*0.5))*1.5;vE=p.z;gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);}`,
        fragmentShader: `uniform vec3 uColor1,uColor2;uniform float uTime;varying vec2 vUv;varying float vE;
          void main(){vec3 c=mix(uColor1,uColor2,vE*0.15+0.5);c+=smoothstep(1.5,2.0,vE)*0.5;gl_FragColor=vec4(c,0.4+0.1*sin(vUv.x*20.0+uTime));}`,
        transparent:true, side:THREE.DoubleSide
      });
    }
    function createFireMat(c1, c2) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uColor1:{value:new THREE.Color(c1)}, uColor2:{value:new THREE.Color(c2)} },
        vertexShader: `uniform float uTime;varying vec2 vUv;${noiseGLSL}
          void main(){vUv=uv;vec3 p=position;p+=normal*snoise(vec3(p.xy*2.0-vec2(0,uTime*2.0),uTime*0.5))*0.5;gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.0);}`,
        fragmentShader: `uniform float uTime;uniform vec3 uColor1,uColor2;varying vec2 vUv;
          void main(){float g=1.0-vUv.y;vec3 c=mix(uColor2,uColor1,g)*(1.0+g*1.5);gl_FragColor=vec4(c,g*0.8);}`,
        transparent:true, side:THREE.DoubleSide, depthWrite:false
      });
    }
    function createInkMat(c1, c2) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uColor1:{value:new THREE.Color(c1)}, uColor2:{value:new THREE.Color(c2)} },
        vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader: `uniform float uTime;uniform vec3 uColor1,uColor2;varying vec2 vUv;${noiseGLSL}
          void main(){float n1=snoise(vec3(vUv*3.0,uTime*0.2));float n2=snoise(vec3(vUv*6.0,uTime*0.1+100.0));float ink=smoothstep(0.0,0.5,n1*0.5+0.5);vec3 c=mix(uColor1,uColor2,ink+n2*0.3);c+=0.3*(1.0-smoothstep(0.3,0.5,abs(n1)));gl_FragColor=vec4(c,0.4+ink*0.3);}`,
        transparent:true, side:THREE.DoubleSide
      });
    }
    function createCrystalMat(c1, c2) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uColor1:{value:new THREE.Color(c1)}, uColor2:{value:new THREE.Color(c2)} },
        vertexShader: `varying vec3 vN,vW,vL;void main(){vN=normalize(normalMatrix*normal);vW=(modelMatrix*vec4(position,1.0)).xyz;vL=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader: `uniform float uTime;uniform vec3 uColor1,uColor2;varying vec3 vN,vW,vL;${noiseGLSL}
          void main(){vec3 v=normalize(cameraPosition-vW);float f=pow(1.0-max(dot(vN,v),0.0),3.0);float veins=snoise(vL*2.0+uTime*0.1);vec3 c=mix(uColor1,uColor2,veins*0.5+0.5);c+=pow(max(dot(reflect(-v,vN),vec3(0.5,1,0.5)),0.0),20.0)*0.5;c+=f*uColor2*0.8;gl_FragColor=vec4(c,0.7+f*0.3);}`,
        transparent:true
      });
    }
    function createMatrixMat(color) {
      return new THREE.ShaderMaterial({
        uniforms: { uTime:{value:0}, uColor:{value:new THREE.Color(color)} },
        vertexShader: `varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
        fragmentShader: `uniform float uTime;uniform vec3 uColor;varying vec2 vUv;
          float random(vec2 st){return fract(sin(dot(st,vec2(12.9898,78.233)))*43758.5453);}
          void main(){vec2 g=floor(vUv*vec2(30,40));float r=random(g);float s=r*3.0+1.0;float ch=step(0.5,fract(r*100.0+uTime*s));float b=ch*(0.5+0.5*sin(uTime*s+r*6.28));float f=1.0-vUv.y;gl_FragColor=vec4(uColor*b*f*1.5,b*f*0.8);}`,
        transparent:true, side:THREE.DoubleSide, depthWrite:false
      });
    }

    // é£æ ¼ â†’ shader æ˜ å°„
    function getStyleShaderMaterial(id, a, a2) {
      const M = {
        glass:()=>createFluidMat(a,a2,{def:1,op:0.5}), neon:()=>createGlowMat(a,a2,{ps:3,gi:2}),
        cyber:()=>createGlowMat(a,a2,{ps:4,gi:2.5}), aurora:()=>createAuroraMat(a,a2),
        japanese:()=>createInkMat(a,a2), gothic:()=>createCrystalMat(a,a2),
        holographic:()=>createHoloMat(), glitch:()=>createGlitchMat(a,a2,{i:0.8}),
        vaporwave:()=>createFluidMat(a,a2,{spd:0.2,def:0.5}), pixel:()=>createGlowMat(a,a2,{ps:8,gi:1}),
        matrix:()=>createMatrixMat(a), terminal:()=>createMatrixMat(a),
        chinese:()=>createInkMat(a,a2), ocean:()=>createWaterMat(a,a2),
        romantic:()=>createFluidMat(a,a2,{def:0.6,op:0.6}), steampunk:()=>createCrystalMat(a,a2),
        sunset:()=>createFireMat(a,a2), winter:()=>createCrystalMat('#aaccff','#eeeeff'),
        forest:()=>createFluidMat(a,a2,{def:0.5}), kawaii:()=>createFluidMat(a,a2,{def:1.2,spd:0.6,op:0.6}),
        artdeco:()=>createCrystalMat(a,a2), gradient:()=>createFluidMat(a,a2,{def:1.5,spd:0.5}),
        synthwave:()=>createGlowMat(a,a2,{ps:2,gi:1.5}), zen:()=>createInkMat(a,a2),
        midnight:()=>createGlowMat('#191970','#ffffff',{ps:0.5,gi:1}),
        watercolor:()=>createInkMat(a,a2), desert:()=>createFireMat(a,a2),
        spring:()=>createFluidMat(a,a2,{def:0.6}), autumn:()=>createFireMat(a,a2),
        liminalspace:()=>createGlitchMat('#c0c0c0','#808080',{i:0.3}),
        weirdcore:()=>createGlitchMat(a,a2,{i:1}), dreamcore:()=>createFluidMat(a,a2,{def:1,spd:0.2,op:0.4}),
        ios:()=>createFluidMat(a,a2,{def:0.3,op:0.5}), material:()=>createFluidMat(a,a2,{def:0.4}),
        spotify:()=>createGlowMat(a,'#111',{ps:2}), gaming:()=>createGlowMat(a,a2,{ps:5,gi:2}),
        music:()=>createGlowMat(a,a2,{ps:3}), fashion:()=>createCrystalMat('#111',a2),
        marble:()=>createCrystalMat(a,a2), metal:()=>createCrystalMat(a,a2),
        indian:()=>createFluidMat(a,a2,{def:0.7}), arabian:()=>createGlowMat(a,a2,{ps:1,gi:1.5}),
        luxury:()=>createCrystalMat(a,a2), stormy:()=>createGlitchMat('#333',a2,{i:0.6}),
        frutiger:()=>createFluidMat(a,a2,{def:0.5,op:0.35}), solarpunk:()=>createFluidMat(a,a2,{def:0.4}),
        darkacademia:()=>createCrystalMat(a,a2), victorian:()=>createCrystalMat(a,a2),
        memphis:()=>createGlowMat(a,a2,{ps:4}), popart:()=>createGlowMat(a,a2,{ps:6,gi:2}),
        energetic:()=>createFireMat(a,a2), sports:()=>createFireMat(a,a2),
        mysterious:()=>createGlowMat(a,a2,{ps:1.5,gi:2}), coral:()=>createWaterMat(a,a2),
        mediterranean:()=>createWaterMat(a,a2), rainy:()=>createWaterMat(a,a2), melancholy:()=>createWaterMat(a,a2),
        dawn:()=>createFireMat(a,a2), dusk:()=>createFireMat(a,a2), summer:()=>createFireMat(a,a2),
        cheerful:()=>createGlowMat(a,a2,{ps:3,gi:1.5}),
        neumorphism:()=>createFluidMat(a,a2,{def:0.3,op:0.5}), clay:()=>createFluidMat(a,a2,{def:1.5,spd:0.8,op:0.7}),
        // è¡¥å……
        github:()=>createGlowMat(a,a2,{ps:1,gi:1}), discord:()=>createGlowMat(a,a2,{ps:2,gi:1.5}),
        figma:()=>createGlowMat(a,a2,{ps:3,gi:1.5}), stripe:()=>createGlowMat(a,a2,{ps:1.5,gi:1.5}),
        fluent:()=>createFluidMat(a,a2,{def:0.3,op:0.4}), notion:()=>createFluidMat('#fff','#888',{def:0.2,op:0.3}),
        linear:()=>createGlowMat(a,a2,{ps:1.5,gi:1.2}), korean:()=>createFluidMat(a,a2,{def:0.4,op:0.5}),
        african:()=>createCrystalMat(a,a2), greek:()=>createCrystalMat(a,'#eee'),
        bauhaus:()=>createGlowMat(a,a2,{ps:2,gi:1}), dieselpunk:()=>createCrystalMat(a,a2),
        comic:()=>createGlowMat(a,a2,{ps:5,gi:2}), sketch:()=>createFluidMat(a,a2,{def:0.2,op:0.4}),
        abstract:()=>createFluidMat(a,a2,{def:0.8}), brutal:()=>createGlowMat(a,a2,{ps:4,gi:2}),
        poster:()=>createGlowMat(a,a2,{ps:3,gi:1.5}), swiss:()=>createGlowMat('#ff0000','#fff',{ps:1,gi:1}),
        nordic:()=>createFluidMat(a,a2,{def:0.3,op:0.4}), muji:()=>createFluidMat(a,a2,{def:0.2,op:0.3}),
        mono:()=>createCrystalMat('#fff','#888'), flat:()=>createGlowMat(a,a2,{ps:2,gi:1}),
        nature:()=>createFluidMat(a,a2,{def:0.5}), wood:()=>createCrystalMat(a,a2),
        paper:()=>createInkMat(a,a2), leather:()=>createCrystalMat(a,a2),
        medical:()=>createGlowMat(a,'#fff',{ps:1,gi:1}), education:()=>createFluidMat(a,a2,{def:0.3}),
        food:()=>createFireMat(a,a2), travel:()=>createGlowMat(a,a2,{ps:2,gi:1.5}),
        kids:()=>createFluidMat(a,a2,{def:1,spd:0.8,op:0.6}), wedding:()=>createFluidMat(a,a2,{def:0.5,op:0.5}),
        cottagecore:()=>createFluidMat(a,a2,{def:0.3,op:0.4}), lightacademia:()=>createInkMat(a,a2),
        handmade:()=>createInkMat(a,a2), sunny:()=>createFireMat(a,a2),
        foggy:()=>createFluidMat('#ccc','#aaa',{def:0.3,op:0.25}), finance:()=>createGlowMat(a,a2,{ps:2,gi:1}),
      };
      return (M[id] || (() => createFluidMat(a, a2)))();
    }

    // æ›´æ–° shader uniforms
    function updateShaderTime(group, time) {
      group.traverse(child => {
        if (child.material && child.material.uniforms && child.material.uniforms.uTime) {
          child.material.uniforms.uTime.value = time;
        }
      });
    }

    // ==================== é£æ ¼æ•°æ® ====================
    const STYLES = [
      // === P0 æ ¸å¿ƒé£æ ¼ ===
      {
        id: 'glass',
        name: 'Glassmorphism',
        nameCN: 'ç»ç’ƒæ‹Ÿæ€',
        desc: 'åŠé€æ˜ç£¨ç ‚è´¨æ„Ÿï¼Œæ¨¡ç³ŠèƒŒæ™¯ï¼Œç°ä»£ç§‘æŠ€æ„Ÿçš„æè‡´ä½“ç°',
        tags: ['ç§‘æŠ€', 'ç°ä»£', 'é€æ˜'],
        icon: 'ğŸ’',
        rarity: 'SSR',
        colors: { accent: '#7c5cff', accent2: '#35d1ff', bg: '#050510', ground: '#0a0a20' },
      },
      {
        id: 'neon',
        name: 'Neon',
        nameCN: 'éœ“è™¹ç¯',
        desc: 'å‘å…‰çš„åŸå¸‚ç¾å­¦ï¼Œå¤œåº—éƒ½å¸‚æ°›å›´ï¼Œèµ›åšå¤œæ™šçš„æ°¸æ’ä¸»é¢˜',
        tags: ['å¤œåº—', 'å‘å…‰', 'éƒ½å¸‚'],
        icon: 'ğŸ’¡',
        rarity: 'SSR',
        colors: { accent: '#ff00ff', accent2: '#00ff00', bg: '#05000a', ground: '#0a0015' },
      },
      {
        id: 'cyber',
        name: 'Cyberpunk',
        nameCN: 'èµ›åšæœ‹å…‹',
        desc: 'é«˜ç§‘æŠ€ä½ç”Ÿæ´»ï¼Œéœ“è™¹ä¸é»‘æš—äº¤ç»‡çš„æœªæ¥éƒ½å¸‚å¹»æƒ³',
        tags: ['ç§‘å¹»', 'æœªæ¥', 'éœ“è™¹'],
        icon: 'ğŸŒƒ',
        rarity: 'SSR',
        colors: { accent: '#00ffff', accent2: '#ff00ff', bg: '#050008', ground: '#080015' },
      },
      {
        id: 'aurora',
        name: 'Aurora',
        nameCN: 'æå…‰',
        desc: 'åŒ—æå¤œç©ºçš„ç¥ç§˜è‰²å½©ï¼Œæ³¢åŠ¨æµæ·Œçš„æ¢¦å¹»å…‰å½±',
        tags: ['æ¢¦å¹»', 'æµåŠ¨', 'è‡ªç„¶'],
        icon: 'âœ¨',
        rarity: 'SSR',
        colors: { accent: '#00ff7f', accent2: '#9370db', bg: '#030810', ground: '#051020' },
      },
      {
        id: 'japanese',
        name: 'Japanese',
        nameCN: 'å’Œé£',
        desc: 'ä¾˜å¯‚ç¾å­¦çš„ä¸œæ–¹æ„å¢ƒï¼Œæ¨±èŠ±çº·é£çš„è¯—æ„ç©ºé—´',
        tags: ['æ—¥å¼', 'ç¦…æ„', 'æ¨±èŠ±'],
        icon: 'ğŸŒ¸',
        rarity: 'SSR',
        colors: { accent: '#ff6b9d', accent2: '#ffb7c5', bg: '#0a0508', ground: '#150810' },
      },
      {
        id: 'gothic',
        name: 'Gothic',
        nameCN: 'å“¥ç‰¹',
        desc: 'æš—çº¢ä¸é»‘è‰²äº¤ç»‡ï¼Œä¸­ä¸–çºªçš„ç¥ç§˜ä¸ææ€–ç¾å­¦',
        tags: ['æš—é»‘', 'ç¥ç§˜', 'ä¸­ä¸–çºª'],
        icon: 'ğŸ¦‡',
        rarity: 'SSR',
        colors: { accent: '#8b0000', accent2: '#4a0080', bg: '#050505', ground: '#100508' },
      },
      {
        id: 'vaporwave',
        name: 'Vaporwave',
        nameCN: 'è’¸æ±½æ³¢',
        desc: '80å¹´ä»£å¤å¤æœªæ¥ä¸»ä¹‰ï¼Œç²‰è“æ¸å˜çš„æ€€æ—§æ¢¦å¢ƒ',
        tags: ['å¤å¤', '80å¹´ä»£', 'æ¢¦å¹»'],
        icon: 'ğŸŒ´',
        rarity: 'SR',
        colors: { accent: '#ff71ce', accent2: '#01cdfe', bg: '#0a0518', ground: '#150820' },
      },
      {
        id: 'pixel',
        name: 'Pixel',
        nameCN: 'åƒç´ é£',
        desc: '8-bitæ¸¸æˆçš„å¤å¤æƒ…æ€€ï¼Œåƒç´ ç‚¹é˜µçš„ç‹¬ç‰¹é­…åŠ›',
        tags: ['æ¸¸æˆ', 'å¤å¤', '8bit'],
        icon: 'ğŸ‘¾',
        rarity: 'SR',
        colors: { accent: '#00ff00', accent2: '#ffff00', bg: '#080810', ground: '#101020' },
      },
      {
        id: 'glitch',
        name: 'Glitch',
        nameCN: 'æ•…éšœè‰ºæœ¯',
        desc: 'RGBåç§»ä¸ç”»é¢æ’•è£‚ï¼Œæ•°å­—ä¸–ç•Œçš„ç¾ä¸½é”™è¯¯',
        tags: ['æ•…éšœ', 'æ•°å­—', 'è‰ºæœ¯'],
        icon: 'ğŸ“º',
        rarity: 'SSR',
        colors: { accent: '#ff00ff', accent2: '#00ffff', bg: '#080808', ground: '#101015' },
      },
      {
        id: 'matrix',
        name: 'Matrix',
        nameCN: 'é»‘å®¢å¸å›½',
        desc: 'ç»¿è‰²ä»£ç é›¨å€¾æ³»è€Œä¸‹ï¼Œæ•°å­—ä¸–ç•Œçš„çœŸç›¸è§‰é†’',
        tags: ['é»‘å®¢', 'ä»£ç ', 'æ•°å­—'],
        icon: 'ğŸ–¥ï¸',
        rarity: 'SR',
        colors: { accent: '#00ff00', accent2: '#00aa00', bg: '#000800', ground: '#001000' },
      },
      // === P1 é‡è¦é£æ ¼ ===
      {
        id: 'holographic',
        name: 'Holographic',
        nameCN: 'å…¨æ¯',
        desc: 'å½©è™¹æ¸å˜çš„é‡‘å±å…‰æ³½ï¼Œæœªæ¥ç§‘æŠ€çš„æŠ•å½±ç¾å­¦',
        tags: ['æœªæ¥', 'æ¸å˜', 'å…‰æ³½'],
        icon: 'ğŸ”®',
        rarity: 'SSR',
        colors: { accent: '#ff6ec7', accent2: '#7df9ff', bg: '#080508', ground: '#100810' },
      },
      {
        id: 'chinese',
        name: 'Chinese',
        nameCN: 'å›½é£',
        desc: 'æœ±çº¢ä¸é‡‘è‰²äº¤ç›¸è¾‰æ˜ ï¼Œä¼ ç»Ÿçº¹æ ·çš„ä¸œæ–¹éŸµå‘³',
        tags: ['ä¸­å¼', 'ä¼ ç»Ÿ', 'å¤å…¸'],
        icon: 'ğŸ®',
        rarity: 'SR',
        colors: { accent: '#ff3333', accent2: '#ffd700', bg: '#0a0505', ground: '#150808' },
      },
      {
        id: 'ocean',
        name: 'Ocean',
        nameCN: 'æµ·æ´‹',
        desc: 'æ·±æµ·çš„ç¥ç§˜å‘¼å”¤ï¼Œæ°´æ¯æ¼‚æµ®çš„æ¢¦å¹»è“å¢ƒ',
        tags: ['æµ·æ´‹', 'æ·±æµ·', 'æµåŠ¨'],
        icon: 'ğŸŒŠ',
        rarity: 'SR',
        colors: { accent: '#0099cc', accent2: '#00ffcc', bg: '#030810', ground: '#051520' },
      },
      {
        id: 'romantic',
        name: 'Romantic',
        nameCN: 'æµªæ¼«',
        desc: 'ç²‰è‰²ä¸çˆ±å¿ƒçš„ç”œèœœæ°›å›´ï¼Œå¹¸ç¦æ—¶åˆ»çš„ç¾å¥½è±¡å¾',
        tags: ['æµªæ¼«', 'ç”œèœœ', 'ç²‰è‰²'],
        icon: 'ğŸ’•',
        rarity: 'SR',
        colors: { accent: '#ff69b4', accent2: '#ffb6c1', bg: '#100508', ground: '#180a10' },
      },
      {
        id: 'steampunk',
        name: 'Steampunk',
        nameCN: 'è’¸æ±½æœ‹å…‹',
        desc: 'ç»´å¤šåˆ©äºšæ—¶ä»£çš„æœºæ¢°ç¾å­¦ï¼Œé½¿è½®ä¸é“œç®¡çš„å¹»æƒ³',
        tags: ['æœºæ¢°', 'å¤å¤', 'å·¥ä¸š'],
        icon: 'âš™ï¸',
        rarity: 'SR',
        colors: { accent: '#b8860b', accent2: '#cd7f32', bg: '#0a0805', ground: '#151008' },
      },
      {
        id: 'sunset',
        name: 'Sunset',
        nameCN: 'æ—¥è½',
        desc: 'é»„æ˜çš„æ¸©æš–æ©™çº¢ï¼Œä¸€å¤©ç»“æŸå‰æœ€æµªæ¼«çš„æ—¶åˆ»',
        tags: ['æ—¥è½', 'æµªæ¼«', 'æ¸©æš–'],
        icon: 'ğŸŒ…',
        rarity: 'R',
        colors: { accent: '#ff6347', accent2: '#ffd700', bg: '#100805', ground: '#201008' },
      },
      {
        id: 'winter',
        name: 'Winter',
        nameCN: 'å†¬å¤©',
        desc: 'å†°è“ç™½é›ªçš„çº¯å‡€ä¸–ç•Œï¼Œå®é™ç¥¥å’Œçš„é“¶ç™½å­£èŠ‚',
        tags: ['å†¬å¤©', 'çº¯å‡€', 'é›ªèŠ±'],
        icon: 'â„ï¸',
        rarity: 'R',
        colors: { accent: '#60a5fa', accent2: '#c4b5fd', bg: '#050810', ground: '#081020' },
      },
      {
        id: 'forest',
        name: 'Forest',
        nameCN: 'æ£®æ—',
        desc: 'æ·±ç»¿æš—è°ƒçš„ç¥ç§˜æ—åœ°ï¼Œè¤ç«è™«ç‚¹äº®çš„é­”æ³•ç©ºé—´',
        tags: ['æ£®æ—', 'ç¥ç§˜', 'è¤ç«è™«'],
        icon: 'ğŸŒ²',
        rarity: 'R',
        colors: { accent: '#228b22', accent2: '#7cfc00', bg: '#030805', ground: '#051008' },
      },
      {
        id: 'kawaii',
        name: 'Kawaii',
        nameCN: 'å¯çˆ±ç²‰å½©',
        desc: 'é©¬å¡é¾™é…è‰²çš„æ²»æ„ˆç³»ï¼Œåœ†æ¶¦å¯çˆ±çš„æ—¥ç³»ç¾å­¦',
        tags: ['å¯çˆ±', 'æ—¥ç³»', 'ç²‰å½©'],
        icon: 'ğŸ€',
        rarity: 'SR',
        colors: { accent: '#ffb7c5', accent2: '#b19cd9', bg: '#100810', ground: '#180c18' },
      },
      {
        id: 'artdeco',
        name: 'Art Deco',
        nameCN: 'è£…é¥°è‰ºæœ¯',
        desc: 'å‡ ä½•å¯¹ç§°ä¸é‡‘è‰²è£…é¥°ï¼Œçˆµå£«æ—¶ä»£çš„å¥¢åä¼˜é›…',
        tags: ['å¥¢å', 'å‡ ä½•', 'é‡‘è‰²'],
        icon: 'ğŸ›ï¸',
        rarity: 'SR',
        colors: { accent: '#d4af37', accent2: '#ffd700', bg: '#08080f', ground: '#101018' },
      },
      // === æ›´å¤šé£æ ¼ ===
      { id:'gradient', name:'Gradient', nameCN:'æ¸å˜æµä½“', desc:'å¤šå½©æ¸å˜çš„æµåŠ¨è‰ºæœ¯ï¼Œè‰²å½©çš„äº¤èç››å®´', tags:['æ¸å˜','æµåŠ¨'], icon:'ğŸŒˆ', rarity:'R', colors:{ accent:'#667eea', accent2:'#f093fb', bg:'#080510', ground:'#100818' } },
      { id:'synthwave', name:'Synthwave', nameCN:'åˆæˆæ³¢', desc:'ç´«çº¢è½æ—¥çš„ç”µå­æ¢¦å¢ƒï¼Œå¤å¤æœªæ¥çš„å£°å…‰', tags:['å¤å¤','éœ“è™¹'], icon:'ğŸ¹', rarity:'SR', colors:{ accent:'#f72585', accent2:'#7209b7', bg:'#0a0510', ground:'#150818' } },
      { id:'zen', name:'Zen', nameCN:'ç¦…æ„', desc:'æ¯å±±æ°´çš„æç®€é™è°§ï¼Œå†…å¿ƒå®é™çš„ä¸œæ–¹å“²å­¦', tags:['ç¦…æ„','å¹³é™'], icon:'â˜¯ï¸', rarity:'R', colors:{ accent:'#8fbc8f', accent2:'#d2b48c', bg:'#080a08', ground:'#101510' } },
      { id:'midnight', name:'Midnight', nameCN:'åˆå¤œ', desc:'æ·±å¤œæ˜Ÿç©ºçš„ç¥ç§˜æ—¶åˆ»ï¼Œä¸‡ç±ä¿±å¯‚çš„æ·±é‚ƒ', tags:['åˆå¤œ','æ˜Ÿç©º'], icon:'ğŸŒ™', rarity:'R', colors:{ accent:'#191970', accent2:'#4b0082', bg:'#030508', ground:'#050810' } },
      { id:'watercolor', name:'Watercolor', nameCN:'æ°´å½©', desc:'æŸ”å’Œæ™•æŸ“çš„è‰ºæœ¯æ°”è´¨ï¼Œé€æ˜å±‚å çš„è¯—æ„', tags:['è‰ºæœ¯','æ‰‹ç»˜'], icon:'ğŸ¨', rarity:'SR', colors:{ accent:'#87ceeb', accent2:'#dda0dd', bg:'#080a10', ground:'#101520' } },
      { id:'terminal', name:'Terminal', nameCN:'ç»ˆç«¯', desc:'å‘½ä»¤è¡Œçš„å¤å¤ç§‘æŠ€æ„Ÿï¼Œç»¿è‰²ç£·å…‰çš„å‘¢å–ƒ', tags:['ä»£ç ','ç»ˆç«¯'], icon:'âŒ¨ï¸', rarity:'R', colors:{ accent:'#00ff00', accent2:'#00aa00', bg:'#000500', ground:'#000a00' } },
      { id:'desert', name:'Desert', nameCN:'æ²™æ¼ ', desc:'å¹¿è¢¤è’åŸçš„è‹å‡‰ä¹‹ç¾ï¼Œé‡‘æ²™é£æ‰¬çš„å¯‚å¯', tags:['æ²™æ¼ ','è’å‡‰'], icon:'ğŸœï¸', rarity:'N', colors:{ accent:'#daa520', accent2:'#cd853f', bg:'#100a05', ground:'#201508' } },
      { id:'spring', name:'Spring', nameCN:'æ˜¥å¤©', desc:'ä¸‡ç‰©å¤è‹çš„ç”Ÿå‘½åŠ›ï¼Œå«©ç»¿ç²‰è‰²çš„æ–°èŠ½', tags:['æ˜¥å¤©','ç”Ÿæœº'], icon:'ğŸŒ·', rarity:'R', colors:{ accent:'#98fb98', accent2:'#ffb7c5', bg:'#050a08', ground:'#081510' } },
      { id:'autumn', name:'Autumn', nameCN:'ç§‹å¤©', desc:'é‡‘è‰²è½å¶çš„æˆç†Ÿæ¸©æš–ï¼Œä¸°æ”¶å­£èŠ‚çš„ç¾ä¸½', tags:['ç§‹å¤©','è½å¶'], icon:'ğŸ‚', rarity:'R', colors:{ accent:'#ff8c00', accent2:'#8b4513', bg:'#100805', ground:'#201008' } },
      { id:'liminalspace', name:'Liminal Space', nameCN:'é˜ˆé™ç©ºé—´', desc:'è¯¡å¼‚ç†Ÿæ‚‰çš„è¿‡æ¸¡ç©ºé—´ï¼Œä»‹äºç°å®ä¸æ¢¦å¢ƒ', tags:['è¯¡å¼‚','è¶…ç°å®'], icon:'ğŸšª', rarity:'SSR', colors:{ accent:'#c0c0c0', accent2:'#808080', bg:'#0a0a0a', ground:'#151515' } },
      // === å“ç‰Œç³» ===
      { id:'ios', name:'iOS', nameCN:'è‹¹æœé£', desc:'æ¯›ç»ç’ƒæ•ˆæœä¸åœ†æ¶¦å›¾æ ‡ï¼Œè‹¹æœè®¾è®¡çš„ä¼˜é›…ç®€æ´', tags:['è‹¹æœ','ç®€æ´'], icon:'ğŸ', rarity:'SR', colors:{ accent:'#007aff', accent2:'#5856d6', bg:'#0a0a10', ground:'#101520' } },
      { id:'material', name:'Material You', nameCN:'Material', desc:'GoogleåŠ¨æ€é…è‰²ç³»ç»Ÿï¼ŒMaterial3çš„æµç•…ä½“éªŒ', tags:['è°·æ­Œ','ç°ä»£'], icon:'ğŸ¨', rarity:'SR', colors:{ accent:'#6750a4', accent2:'#d0bcff', bg:'#0a0810', ground:'#151020' } },
      { id:'github', name:'GitHub', nameCN:'GitHub', desc:'ä»£ç æ‰˜ç®¡çš„æ•°å­—å®¶å›­ï¼Œå¼€å‘è€…çš„ç»¿è‰²è´¡çŒ®å›¾', tags:['ä»£ç ','ç¤¾åŒº'], icon:'ğŸ™', rarity:'R', colors:{ accent:'#238636', accent2:'#58a6ff', bg:'#050810', ground:'#0d1117' } },
      { id:'spotify', name:'Spotify', nameCN:'Spotify', desc:'éŸ³ä¹ä¸–ç•Œçš„å¾‹åŠ¨èŠ‚å¥ï¼Œç»¿é»‘é…è‰²çš„å£°æ³¢', tags:['éŸ³ä¹','å¾‹åŠ¨'], icon:'ğŸµ', rarity:'R', colors:{ accent:'#1db954', accent2:'#191414', bg:'#050805', ground:'#121212' } },
      { id:'discord', name:'Discord', nameCN:'Discord', desc:'æ¸¸æˆç¤¾äº¤çš„ç´«è“ç©ºé—´ï¼Œç¤¾åŒºæ°›å›´çš„æ¬¢å£°', tags:['ç¤¾äº¤','æ¸¸æˆ'], icon:'ğŸ§', rarity:'R', colors:{ accent:'#5865f2', accent2:'#eb459e', bg:'#080810', ground:'#2f3136' } },
      { id:'figma', name:'Figma', nameCN:'Figma', desc:'è®¾è®¡å·¥å…·çš„åˆ›æ„ç”»å¸ƒï¼Œå¤šå½©æš—è‰²çš„çµæ„Ÿç©ºé—´', tags:['è®¾è®¡','åˆ›æ„'], icon:'ğŸ–Œï¸', rarity:'R', colors:{ accent:'#f24e1e', accent2:'#a259ff', bg:'#080808', ground:'#101010' } },
      { id:'stripe', name:'Stripe', nameCN:'Stripe', desc:'æ”¯ä»˜å¹³å°çš„æ·±è“æ¸å˜ï¼Œå®‰å…¨ä¸“ä¸šçš„ä¿¡ä»»', tags:['æ”¯ä»˜','ä¸“ä¸š'], icon:'ğŸ’³', rarity:'R', colors:{ accent:'#635bff', accent2:'#00d4ff', bg:'#050810', ground:'#0a1020' } },
      { id:'fluent', name:'Fluent', nameCN:'Fluent', desc:'å¾®è½¯æµç•…è®¾è®¡çš„æ¯›ç»ç’ƒå±‚æ¬¡æ„Ÿ', tags:['å¾®è½¯','æµç•…'], icon:'ğŸªŸ', rarity:'R', colors:{ accent:'#0078d4', accent2:'#00bcf2', bg:'#050810', ground:'#0a1020' } },
      { id:'notion', name:'Notion', nameCN:'Notion', desc:'ç¬”è®°åä½œçš„æç®€é»‘ç™½ï¼ŒçŸ¥è¯†ç®¡ç†çš„çº¯å‡€', tags:['ç¬”è®°','æç®€'], icon:'ğŸ“', rarity:'N', colors:{ accent:'#ffffff', accent2:'#787878', bg:'#0a0a0a', ground:'#151515' } },
      { id:'linear', name:'Linear', nameCN:'Linear', desc:'é¡¹ç›®ç®¡ç†çš„æš—ç´«æç®€ï¼Œé«˜æ•ˆå·¥å…·çš„æ²‰é™', tags:['æ•ˆç‡','æš—è‰²'], icon:'ğŸ“Š', rarity:'R', colors:{ accent:'#5e6ad2', accent2:'#8b5cf6', bg:'#050510', ground:'#0a0818' } },
      // === æ–‡åŒ–ç³» ===
      { id:'korean', name:'Korean', nameCN:'éŸ©é£', desc:'æ¸…æ–°æŸ”å’Œçš„ç²‰è“é…è‰²ï¼Œç°ä»£ç®€çº¦çš„äºšæ´²ç¾å­¦', tags:['éŸ©å¼','æ¸…æ–°'], icon:'ğŸ‡°ğŸ‡·', rarity:'R', colors:{ accent:'#ffb6c1', accent2:'#87ceeb', bg:'#0a080f', ground:'#151020' } },
      { id:'indian', name:'Indian', nameCN:'å°åº¦é£', desc:'é¦™æ–™è‰²å½©ä¸æ›¼é™€ç½—å›¾æ¡ˆï¼Œçƒ­æƒ…å¥”æ”¾çš„å¼‚åŸŸé£æƒ…', tags:['å°åº¦','çƒ­æƒ…'], icon:'ğŸª”', rarity:'SR', colors:{ accent:'#ff9933', accent2:'#128807', bg:'#0a0805', ground:'#1a1008' } },
      { id:'arabian', name:'Arabian', nameCN:'ä¸­ä¸œé£', desc:'æ³¢æ–¯çº¹æ ·ä¸é‡‘è“é…è‰²ï¼Œåƒä¸€å¤œçš„ç¥ç§˜æ–‡æ˜', tags:['ä¸­ä¸œ','å¥¢å'], icon:'ğŸ•Œ', rarity:'SR', colors:{ accent:'#1e90ff', accent2:'#ffd700', bg:'#050810', ground:'#0a1020' } },
      { id:'african', name:'African', nameCN:'éæ´²é£', desc:'éƒ¨è½å›¾æ¡ˆä¸å¤§åœ°æš–è‰²ï¼ŒåŸå§‹åŠ›é‡çš„ç”Ÿå‘½èµæ­Œ', tags:['éæ´²','åŠ›é‡'], icon:'ğŸŒ', rarity:'R', colors:{ accent:'#cd853f', accent2:'#8b4513', bg:'#0a0805', ground:'#1a1008' } },
      { id:'greek', name:'Greek', nameCN:'å¸Œè…Šé£', desc:'çˆ±ç´æµ·è“ç™½ä¸å¤å…¸æŸ±å¼ï¼Œè¥¿æ–¹æ–‡æ˜çš„æ‘‡ç¯®', tags:['å¸Œè…Š','å¤å…¸'], icon:'ğŸ›ï¸', rarity:'R', colors:{ accent:'#0066cc', accent2:'#e0e0e0', bg:'#050810', ground:'#0a1520' } },
      { id:'mediterranean', name:'Mediterranean', nameCN:'åœ°ä¸­æµ·', desc:'è“ç™½é˜³å…‰æµ·å²¸çš„æµªæ¼«é£æƒ…ï¼Œåº¦å‡å¤©å ‚', tags:['åº¦å‡','é˜³å…‰'], icon:'ğŸ–ï¸', rarity:'R', colors:{ accent:'#1e90ff', accent2:'#ffffff', bg:'#050a10', ground:'#081520' } },
      // === æ›´å¤šå¤å¤ç³» ===
      { id:'memphis', name:'Memphis', nameCN:'å­Ÿè²æ–¯', desc:'80å¹´ä»£åç°ä»£çš„å‡ ä½•æ’è‰²è§†è§‰å†²å‡»', tags:['åç°ä»£','æ’è‰²'], icon:'ğŸ”º', rarity:'SR', colors:{ accent:'#ff6b6b', accent2:'#4ecdc4', bg:'#0a0810', ground:'#151020' } },
      { id:'bauhaus', name:'Bauhaus', nameCN:'åŒ…è±ªæ–¯', desc:'å‡ ä½•åŸºç¡€ä¸ä¸‰åŸè‰²ï¼ŒåŠŸèƒ½ä¸»ä¹‰è®¾è®¡ä¹‹æº', tags:['å‡ ä½•','åŠŸèƒ½'], icon:'ğŸ”µ', rarity:'R', colors:{ accent:'#e63946', accent2:'#457b9d', bg:'#080a0f', ground:'#101520' } },
      { id:'victorian', name:'Victorian', nameCN:'ç»´å¤šåˆ©äºš', desc:'åä¸½æš—é‡‘çš„å¤å…¸ä¼˜é›…ï¼Œè´µæ—é£èŒƒçš„æè‡´', tags:['å¤å…¸','åä¸½'], icon:'ğŸ‘‘', rarity:'SR', colors:{ accent:'#8b4513', accent2:'#daa520', bg:'#080505', ground:'#100a08' } },
      { id:'dieselpunk', name:'Dieselpunk', nameCN:'æŸ´æ²¹æœ‹å…‹', desc:'äºŒæˆ˜å·¥ä¸šçš„é‡å‹æœºæ¢°ï¼Œç²—çŠ·ç¾å­¦çš„åŠ›é‡', tags:['å·¥ä¸š','ç²—çŠ·'], icon:'ğŸ­', rarity:'R', colors:{ accent:'#696969', accent2:'#8b4513', bg:'#080808', ground:'#101010' } },
      // === æ›´å¤šè‰ºæœ¯ç³» ===
      { id:'comic', name:'Comic', nameCN:'æ¼«ç”»', desc:'ç²—é»‘æè¾¹ä¸çˆ†ç‚¸æ–‡å­—ï¼Œè§†è§‰å¼ åŠ›çš„åŠ¨æ€è‰ºæœ¯', tags:['æ¼«ç”»','å¡é€š'], icon:'ğŸ’¥', rarity:'R', colors:{ accent:'#ffff00', accent2:'#ff0000', bg:'#0a0a10', ground:'#151520' } },
      { id:'sketch', name:'Sketch', nameCN:'ç´ æ', desc:'é“…ç¬”çº¿æ¡çš„æ‰‹ç»˜è´¨æ„Ÿï¼Œè‰å›¾é£æ ¼çš„è‰ºæœ¯æ°”æ¯', tags:['æ‰‹ç»˜','çº¿æ¡'], icon:'âœï¸', rarity:'R', colors:{ accent:'#808080', accent2:'#a0a0a0', bg:'#0a0a0a', ground:'#151515' } },
      { id:'popart', name:'Pop Art', nameCN:'æ³¢æ™®è‰ºæœ¯', desc:'å¤§èƒ†æ’è‰²çš„é‡å¤å›¾æ¡ˆï¼Œå®‰è¿ªæ²ƒéœå°”çš„è§†è§‰é©å‘½', tags:['æ³¢æ™®','å¤§èƒ†'], icon:'ğŸŒ', rarity:'SR', colors:{ accent:'#ff1493', accent2:'#00ff00', bg:'#0a0508', ground:'#150810' } },
      { id:'abstract', name:'Abstract', nameCN:'æŠ½è±¡', desc:'éå…·è±¡çš„å‡ ä½•å½¢æ€ï¼Œç°ä»£è‰ºæœ¯çš„è‡ªç”±è¡¨è¾¾', tags:['æŠ½è±¡','ç°ä»£'], icon:'ğŸ­', rarity:'R', colors:{ accent:'#ff6347', accent2:'#4169e1', bg:'#08080a', ground:'#101015' } },
      // === æµ·æŠ¥ç³» ===
      { id:'brutal', name:'Neo-Brutalism', nameCN:'æ–°ç²—é‡ä¸»ä¹‰', desc:'ç²—é»‘è¾¹æ¡†ä¸ç¡¬é˜´å½±ï¼Œå¤§èƒ†ç›´æ¥çš„è§†è§‰å†²å‡»', tags:['å¤§èƒ†','ç¡¬æœ—'], icon:'ğŸ”²', rarity:'R', colors:{ accent:'#ff4500', accent2:'#ffd700', bg:'#101010', ground:'#1a1a1a' } },
      { id:'poster', name:'Poster', nameCN:'æµ·æŠ¥é£', desc:'å¼ºå¯¹æ¯”å—é¢çš„è§†è§‰å†²å‡»åŠ›è®¾è®¡è¡¨è¾¾', tags:['æµ·æŠ¥','é«˜å¯¹æ¯”'], icon:'ğŸ“°', rarity:'R', colors:{ accent:'#ff4500', accent2:'#ffd700', bg:'#080505', ground:'#100a08' } },
      // === æƒ…ç»ªç³» ===
      { id:'energetic', name:'Energetic', nameCN:'æ´»åŠ›', desc:'æ©™é»„é…è‰²çš„åŠ¨æ„Ÿå…ƒç´ ï¼Œå……æ»¡æ¿€æƒ…çš„è¿åŠ¨æ„Ÿ', tags:['æ´»åŠ›','åŠ¨æ„Ÿ'], icon:'âš¡', rarity:'R', colors:{ accent:'#ff8c00', accent2:'#ffd700', bg:'#100805', ground:'#201008' } },
      { id:'mysterious', name:'Mysterious', nameCN:'ç¥ç§˜', desc:'æ·±ç´«æš—å½±çš„æœªçŸ¥ä¸–ç•Œï¼Œç¥ç§˜åŠ›é‡çš„ä½è¯­', tags:['ç¥ç§˜','æ·±é‚ƒ'], icon:'ğŸ”®', rarity:'R', colors:{ accent:'#663399', accent2:'#9932cc', bg:'#050510', ground:'#080818' } },
      { id:'cheerful', name:'Cheerful', nameCN:'æ¬¢å¿«', desc:'æ˜é»„é…è‰²çš„é˜³å…‰ç§¯æï¼Œå¿«ä¹å¿ƒæƒ…çš„ç»½æ”¾', tags:['é˜³å…‰','å¿«ä¹'], icon:'ğŸ˜Š', rarity:'N', colors:{ accent:'#ffd700', accent2:'#ffb347', bg:'#100a05', ground:'#201508' } },
      { id:'melancholy', name:'Melancholy', nameCN:'å¿§éƒ', desc:'è“ç°é›¨å¤©çš„æ²‰æ€è¯—æ„ï¼Œé›¨æ»´æ•²æ‰“çš„ä½è¯­', tags:['å¿§éƒ','æ²‰æ€'], icon:'ğŸŒ§ï¸', rarity:'N', colors:{ accent:'#708090', accent2:'#4682b4', bg:'#050810', ground:'#081015' } },
      // === æç®€ç³» ===
      { id:'swiss', name:'Swiss Design', nameCN:'ç‘å£«è®¾è®¡', desc:'ç½‘æ ¼ç³»ç»Ÿçš„ç†æ€§ç¾å­¦ï¼Œçº¢é»‘é…è‰²çš„ç²¾ç¡®', tags:['æç®€','ç†æ€§'], icon:'ğŸ‡¨ğŸ‡­', rarity:'R', colors:{ accent:'#ff0000', accent2:'#000000', bg:'#0a0a0a', ground:'#151515' } },
      { id:'nordic', name:'Nordic', nameCN:'åŒ—æ¬§é£', desc:'åŠŸèƒ½ä¸»ä¹‰çš„æ¸©æš–èˆ’é€‚ï¼Œç°è“è°ƒçš„ç”Ÿæ´»ç¾å­¦', tags:['åŒ—æ¬§','æ¸©æš–'], icon:'ğŸ ', rarity:'R', colors:{ accent:'#5f9ea0', accent2:'#deb887', bg:'#0a0a0f', ground:'#101518' } },
      { id:'muji', name:'MUJI', nameCN:'æ— å°é£', desc:'ç±³ç™½å¤§åœ°è‰²çš„æœ´ç´ è‡ªç„¶ï¼Œè¿”ç’å½’çœŸçš„å“²å­¦', tags:['è‡ªç„¶','æœ´ç´ '], icon:'ğŸƒ', rarity:'N', colors:{ accent:'#d2b48c', accent2:'#8b7355', bg:'#0a0908', ground:'#151510' } },
      { id:'mono', name:'Monochrome', nameCN:'é»‘ç™½', desc:'é»‘ç™½ç°å¼ºå¯¹æ¯”çš„çº¯ç²¹ï¼Œæ‘„å½±æ„Ÿçš„å…‰å½±ä¸–ç•Œ', tags:['é»‘ç™½','å¯¹æ¯”'], icon:'ğŸ–¤', rarity:'N', colors:{ accent:'#ffffff', accent2:'#808080', bg:'#080808', ground:'#101010' } },
      { id:'luxury', name:'Luxury', nameCN:'å¥¢æ„Ÿ', desc:'ä½é¥±å’Œç»†çº¿æ¡çš„å¤§ç•™ç™½ï¼Œæè‡´çš„é«˜çº§è´¨æ„Ÿ', tags:['å¥¢å','ç²¾è‡´'], icon:'ğŸ’', rarity:'SR', colors:{ accent:'#c9b037', accent2:'#d4af37', bg:'#080808', ground:'#101010' } },
      { id:'flat', name:'Flat', nameCN:'æ‰å¹³', desc:'æ— é˜´å½±çº¯è‰²å—çš„ç°ä»£ç®€æ´ï¼Œæ•°å­—ç¾å­¦ä¹‹æº', tags:['æ‰å¹³','ç®€æ´'], icon:'ğŸ“', rarity:'N', colors:{ accent:'#3498db', accent2:'#e74c3c', bg:'#0a0a0f', ground:'#101518' } },
      // === è‡ªç„¶ç³» ===
      { id:'nature', name:'Nature', nameCN:'è‡ªç„¶', desc:'ç»¿è‰²æœ‰æœºå½¢æ€çš„ç”Ÿæ€å‹å¥½ï¼Œå¤§è‡ªç„¶çš„å‘¼å¸', tags:['è‡ªç„¶','ç”Ÿæ€'], icon:'ğŸŒ¿', rarity:'N', colors:{ accent:'#22c55e', accent2:'#84cc16', bg:'#050a05', ground:'#081508' } },
      { id:'ocean', name:'Ocean', nameCN:'æµ·æ´‹', desc:'æ·±æµ·è“ç»¿çš„ç¥ç§˜å‘¼å”¤ï¼Œæ°´æ¯æ¼‚æµ®çš„æ¢¦å¹»', tags:['æµ·æ´‹','æ·±æµ·'], icon:'ğŸŒŠ', rarity:'SR', colors:{ accent:'#0099cc', accent2:'#00ffcc', bg:'#030810', ground:'#051520' } },
      { id:'coral', name:'Coral', nameCN:'çŠç‘š', desc:'çŠç‘šç²‰è‰²çš„æ¸©æŸ”æµ·åº•ï¼Œæ´»åŠ›ä¸æŸ”ç¾çš„äº¤è', tags:['çŠç‘š','æ¸©æŸ”'], icon:'ğŸª¸', rarity:'R', colors:{ accent:'#ff7f50', accent2:'#ff6b6b', bg:'#100808', ground:'#1a1010' } },
      // === æè´¨ç³» ===
      { id:'marble', name:'Marble', nameCN:'å¤§ç†çŸ³', desc:'å†·ç™½ç°è°ƒçš„å¤§ç†çŸ³çº¹ï¼Œå¥¢åå»ºæçš„é«˜è´µæ°”è´¨', tags:['å¤§ç†çŸ³','å¥¢å'], icon:'ğŸ—¿', rarity:'SR', colors:{ accent:'#e0e0e0', accent2:'#a0a0a0', bg:'#080a0a', ground:'#101515' } },
      { id:'metal', name:'Metal', nameCN:'é‡‘å±', desc:'å†·ç°è‰²è°ƒçš„é‡‘å±å…‰æ³½ï¼Œå·¥ä¸šç¾å­¦çš„ç¡¬æœ—è´¨æ„Ÿ', tags:['é‡‘å±','å·¥ä¸š'], icon:'ğŸ”©', rarity:'R', colors:{ accent:'#808080', accent2:'#c0c0c0', bg:'#080808', ground:'#101010' } },
      { id:'wood', name:'Wood', nameCN:'æœ¨è´¨', desc:'æ¸©æš–æ£•è‰²çš„æœ¨çº¹è‚Œç†ï¼Œè‡ªç„¶æè´¨çš„æ¸©é¦¨è§¦æ„Ÿ', tags:['æœ¨è´¨','æ¸©æš–'], icon:'ğŸªµ', rarity:'N', colors:{ accent:'#8b4513', accent2:'#a0522d', bg:'#0a0805', ground:'#151008' } },
      { id:'paper', name:'Paper', nameCN:'çº¸è´¨', desc:'ç±³é»„çº¸å¼ çš„æ–‡è‰ºè´¨æ„Ÿï¼Œåƒçº¸é¹¤é£ç¿”çš„è¯—ç¯‡', tags:['çº¸å¼ ','æ–‡è‰º'], icon:'ğŸ“œ', rarity:'N', colors:{ accent:'#f5deb3', accent2:'#d2b48c', bg:'#0a0908', ground:'#151510' } },
      { id:'leather', name:'Leather', nameCN:'çš®é©', desc:'å¤å¤æ£•è‰²çš„çš®é©çº¹è·¯ï¼Œé«˜æ¡£æ‰‹å·¥çš„ç²¾è‡´å“å‘³', tags:['çš®é©','å¤å¤'], icon:'ğŸ‘œ', rarity:'R', colors:{ accent:'#8b4513', accent2:'#654321', bg:'#080605', ground:'#100a08' } },
      // === è¡Œä¸šç³» ===
      { id:'gaming', name:'Gaming', nameCN:'ç”µç«', desc:'ç´«ç»¿éœ“è™¹çš„åŠ¨æ„Ÿæ•ˆæœï¼Œç”µå­ç«æŠ€çš„çƒ­è¡€æ¿€æƒ…', tags:['æ¸¸æˆ','ç«æŠ€'], icon:'ğŸ®', rarity:'SR', colors:{ accent:'#8a2be2', accent2:'#00ff00', bg:'#050508', ground:'#0a0810' } },
      { id:'music', name:'Music', nameCN:'éŸ³ä¹', desc:'å£°æ³¢è§†è§‰çš„ç²‰é’å¾‹åŠ¨ï¼ŒéŸ³ç¬¦è·³åŠ¨çš„æ—‹å¾‹ä¸–ç•Œ', tags:['éŸ³ä¹','å¾‹åŠ¨'], icon:'ğŸ¸', rarity:'R', colors:{ accent:'#ff69b4', accent2:'#00ced1', bg:'#080510', ground:'#100818' } },
      { id:'fashion', name:'Fashion', nameCN:'æ—¶å°š', desc:'é»‘ç™½é‡‘é…çš„é«˜çº§æ„Ÿï¼Œæ½®æµå‰æ²¿çš„è§†è§‰è¯­è¨€', tags:['æ—¶å°š','é«˜çº§'], icon:'ğŸ‘—', rarity:'SR', colors:{ accent:'#1a1a1a', accent2:'#ffd700', bg:'#080808', ground:'#101010' } },
      { id:'medical', name:'Medical', nameCN:'åŒ»ç–—', desc:'æ¸…æ´è“ç™½çš„ä¸“ä¸šä¿¡ä»»ï¼Œå¥åº·å®ˆæŠ¤çš„çº¯å‡€ç©ºé—´', tags:['åŒ»ç–—','ä¸“ä¸š'], icon:'ğŸ¥', rarity:'N', colors:{ accent:'#00bfff', accent2:'#ffffff', bg:'#050a10', ground:'#081520' } },
      { id:'finance', name:'Finance', nameCN:'é‡‘è', desc:'ç»¿çº¢æ•°æ®çš„ä¸“ä¸šä¿¡èµ–ï¼Œè´¢å¯Œå¢é•¿çš„è„‰æè·³åŠ¨', tags:['é‡‘è','æ•°æ®'], icon:'ğŸ“ˆ', rarity:'R', colors:{ accent:'#228b22', accent2:'#dc143c', bg:'#050808', ground:'#0a1010' } },
      { id:'education', name:'Education', nameCN:'æ•™è‚²', desc:'çŸ¥è¯†ç»¿è‰²çš„äº²å’ŒåŠ›é‡ï¼Œå­¦ä¹ æˆé•¿çš„å¸Œæœ›ä¹‹è‰²', tags:['æ•™è‚²','çŸ¥è¯†'], icon:'ğŸ“', rarity:'N', colors:{ accent:'#2e8b57', accent2:'#3cb371', bg:'#050a08', ground:'#081510' } },
      { id:'food', name:'Food', nameCN:'é¤é¥®', desc:'æš–æ©™ç»¿é…çš„é£Ÿæ¬²è‰²å½©ï¼Œç¾é£Ÿè¯±æƒ‘çš„æ¸©é¦¨ç©ºé—´', tags:['é¤é¥®','ç¾å‘³'], icon:'ğŸ½ï¸', rarity:'N', colors:{ accent:'#ff8c00', accent2:'#32cd32', bg:'#100805', ground:'#201008' } },
      { id:'travel', name:'Travel', nameCN:'æ—…æ¸¸', desc:'è“æ©™é…è‰²çš„æ¢ç´¢ç²¾ç¥ï¼Œä¸–ç•Œå†’é™©çš„è‡ªç”±é£ç¿”', tags:['æ—…æ¸¸','æ¢ç´¢'], icon:'âœˆï¸', rarity:'R', colors:{ accent:'#1e90ff', accent2:'#ff8c00', bg:'#050810', ground:'#0a1020' } },
      { id:'sports', name:'Sports', nameCN:'è¿åŠ¨', desc:'æ©™ç»¿é…è‰²çš„ç«æŠ€åŠ›é‡ï¼Œæ±—æ°´ä¸è£è€€çš„é—ªè€€', tags:['è¿åŠ¨','æ´»åŠ›'], icon:'âš½', rarity:'R', colors:{ accent:'#ff4500', accent2:'#32cd32', bg:'#100805', ground:'#201008' } },
      { id:'kids', name:'Kids', nameCN:'å„¿ç«¥', desc:'ç³–æœè‰²å½©çš„åœ†æ¶¦å½¢çŠ¶ï¼Œç«¥è¶£ä¸–ç•Œçš„æ¬¢ä¹æ—¶å…‰', tags:['å„¿ç«¥','æ¬¢ä¹'], icon:'ğŸ§¸', rarity:'N', colors:{ accent:'#ff69b4', accent2:'#00ced1', bg:'#100810', ground:'#180c18' } },
      { id:'wedding', name:'Wedding', nameCN:'å©šç¤¼', desc:'ç²‰é‡‘é…è‰²çš„æµªæ¼«ä¼˜é›…ï¼Œå¹¸ç¦æ—¶åˆ»çš„ç¾å¥½è§è¯', tags:['å©šç¤¼','æµªæ¼«'], icon:'ğŸ’’', rarity:'R', colors:{ accent:'#ffb6c1', accent2:'#ffd700', bg:'#100808', ground:'#1a1010' } },
      // === å°ä¼—ç³» ===
      { id:'solarpunk', name:'Solarpunk', nameCN:'é˜³å…‰æœ‹å…‹', desc:'ç»¿è‰²æœªæ¥çš„ä¹è§‚ç§‘æŠ€ï¼Œå¯æŒç»­å‘å±•çš„ç¾å¥½æ„¿æ™¯', tags:['ç”Ÿæ€','ä¹è§‚'], icon:'â˜€ï¸', rarity:'SR', colors:{ accent:'#32cd32', accent2:'#ffd700', bg:'#050a05', ground:'#0a1508' } },
      { id:'cottagecore', name:'Cottagecore', nameCN:'ç”°å›­æ ¸', desc:'ä¹¡æ‘ç”°å›­çš„æ‰‹å·¥è‰ºç¾å­¦ï¼Œå›å½’è‡ªç„¶çš„è¯—æ„ç”Ÿæ´»', tags:['ç”°å›­','è‡ªç„¶'], icon:'ğŸ¡', rarity:'R', colors:{ accent:'#deb887', accent2:'#8fbc8f', bg:'#0a0a08', ground:'#151510' } },
      { id:'darkacademia', name:'Dark Academia', nameCN:'æš—é»‘å­¦é™¢', desc:'å¤å…¸å­¦é™¢çš„æ·±æ£•ä¹¦å·æ°”ï¼ŒçŸ¥æ€§ç¥ç§˜çš„çƒ›å…‰', tags:['å­¦é™¢','çŸ¥æ€§'], icon:'ğŸ“š', rarity:'SR', colors:{ accent:'#3c2415', accent2:'#8b4513', bg:'#080605', ground:'#100a08' } },
      { id:'lightacademia', name:'Light Academia', nameCN:'æµ…è‰²å­¦é™¢', desc:'é˜³å…‰å›¾ä¹¦é¦†çš„æ¸©æš–çŸ¥æ€§ï¼Œç±³ç™½è‰²çš„æ±‚çŸ¥è·¯', tags:['å­¦é™¢','æ¸©å’Œ'], icon:'ğŸ“–', rarity:'R', colors:{ accent:'#f5deb3', accent2:'#d2b48c', bg:'#0a0908', ground:'#151510' } },
      { id:'weirdcore', name:'Weirdcore', nameCN:'æ€ªæ ¸', desc:'ä½è´¨å›¾åƒçš„ä¸åè°ƒç¾å­¦ï¼Œäº’è”ç½‘çš„è¯¡å¼‚æ¢ç´¢', tags:['è¯¡å¼‚','è¶…ç°å®'], icon:'ğŸ‘ï¸', rarity:'SSR', colors:{ accent:'#ff00ff', accent2:'#00ff00', bg:'#080808', ground:'#101010' } },
      { id:'dreamcore', name:'Dreamcore', nameCN:'æ¢¦æ ¸', desc:'æŸ”å’Œå…‰çº¿çš„æ¢¦å¢ƒé€»è¾‘ï¼Œè™šå¹»ä¸–ç•Œçš„è¿·ç¦»ä¹‹ç¾', tags:['æ¢¦å¹»','è¶…ç°å®'], icon:'ğŸ’­', rarity:'SR', colors:{ accent:'#e6e6fa', accent2:'#dda0dd', bg:'#080810', ground:'#101018' } },
      { id:'frutiger', name:'Frutiger Aero', nameCN:'Frutiger', desc:'2000å¹´ä»£çš„æ•°å­—ä¹è§‚ï¼Œé€æ˜æ³¡æ³¡ä¸è‡ªç„¶å…ƒç´ ', tags:['é€æ˜','2000s'], icon:'ğŸ«§', rarity:'SR', colors:{ accent:'#87ceeb', accent2:'#98fb98', bg:'#050a0a', ground:'#081515' } },
      { id:'handmade', name:'Handmade', nameCN:'æ‰‹ä½œ', desc:'æš–ç°çº¸æ„Ÿçš„æŸ”å’Œåœ†è§’ï¼Œäº²å’Œæ¸©æš–çš„æ‰‹å·¥ç¾å­¦', tags:['æ‰‹ä½œ','æ¸©æŸ”'], icon:'ğŸ§¶', rarity:'N', colors:{ accent:'#d2b48c', accent2:'#bc8f8f', bg:'#0a0908', ground:'#151510' } },
      // === å¤©æ°”ç³» ===
      { id:'sunny', name:'Sunny', nameCN:'æ™´å¤©', desc:'é‡‘é»„æ˜äº®çš„é˜³å…‰æ™®ç…§ï¼Œå¿ƒæƒ…æ„‰æ‚¦çš„ç¾å¥½å¤©æ°”', tags:['æ™´å¤©','æ¸©æš–'], icon:'â˜€ï¸', rarity:'N', colors:{ accent:'#ffd700', accent2:'#ff8c00', bg:'#100a05', ground:'#201508' } },
      { id:'rainy', name:'Rainy', nameCN:'é›¨å¤©', desc:'è“ç°è‰²è°ƒçš„é›¨æ»´æ¶Ÿæ¼ªï¼Œå®é™æ²‰æ€çš„å¿§éƒä¹‹ç¾', tags:['é›¨å¤©','å®é™'], icon:'ğŸŒ§ï¸', rarity:'N', colors:{ accent:'#4682b4', accent2:'#708090', bg:'#050810', ground:'#081015' } },
      { id:'stormy', name:'Stormy', nameCN:'æš´é£', desc:'æš—ç°é—ªç”µçš„æˆå‰§å¼ åŠ›ï¼Œç‹‚é£éª¤é›¨çš„è‡ªç„¶åŠ›é‡', tags:['æš´é£','æˆå‰§'], icon:'â›ˆï¸', rarity:'R', colors:{ accent:'#483d8b', accent2:'#ffd700', bg:'#050508', ground:'#0a0810' } },
      { id:'foggy', name:'Foggy', nameCN:'é›¾å¤©', desc:'ç°ç™½æœ¦èƒ§çš„è‹¥éšè‹¥ç°ï¼Œç¥ç§˜è¿·é›¾çš„è™šå¹»ä¸–ç•Œ', tags:['æœ¦èƒ§','ç¥ç§˜'], icon:'ğŸŒ«ï¸', rarity:'N', colors:{ accent:'#c0c0c0', accent2:'#a0a0a0', bg:'#0a0a0a', ground:'#151515' } },
      // === æ—¶é—´ç³» ===
      { id:'dawn', name:'Dawn', nameCN:'é»æ˜', desc:'ç²‰æ©™æ¸å˜çš„æ™¨æ›¦åˆç°ï¼Œæ–°ä¸€å¤©çš„å¸Œæœ›æ›™å…‰', tags:['é»æ˜','å¸Œæœ›'], icon:'ğŸŒ…', rarity:'R', colors:{ accent:'#ffb6c1', accent2:'#ffa07a', bg:'#100808', ground:'#1a1010' } },
      { id:'dusk', name:'Dusk', nameCN:'é»„æ˜', desc:'æ©™ç´«æ¸å˜çš„è½æ—¥ä½™æ™–ï¼Œæµªæ¼«æ€€æ—§çš„é‡‘è‰²æ—¶åˆ»', tags:['é»„æ˜','æµªæ¼«'], icon:'ğŸŒ†', rarity:'R', colors:{ accent:'#ff8c00', accent2:'#9370db', bg:'#100508', ground:'#1a0810' } },
      { id:'summer', name:'Summer', nameCN:'å¤å¤©', desc:'æ˜äº®æ©™é»„çš„é˜³å…‰æµ·æ»©ï¼Œçƒ­æƒ…ä¼¼ç«çš„ç¿çƒ‚å­£èŠ‚', tags:['å¤å¤©','çƒ­æƒ…'], icon:'ğŸ–ï¸', rarity:'R', colors:{ accent:'#ffa500', accent2:'#ff6347', bg:'#100805', ground:'#201008' } },
      // === æ›´å¤šç‰¹æ•ˆç³» ===
      { id:'neumorphism', name:'Neumorphism', nameCN:'æ–°æ‹Ÿç‰©', desc:'æŸ”å’Œå‡¹å‡¸çš„å†…å¤–é˜´å½±ï¼Œæ¸©æŸ”è§¦æ„Ÿçš„è®¾è®¡è¯­è¨€', tags:['æ‹Ÿç‰©','æŸ”å’Œ'], icon:'ğŸ”˜', rarity:'SR', colors:{ accent:'#a0a0b0', accent2:'#c0c0d0', bg:'#101015', ground:'#181820' } },
      { id:'clay', name:'Claymorphism', nameCN:'é»åœŸé£', desc:'3Dè½¯ç³¯è´¨æ„Ÿçš„å½©è‰²é»åœŸï¼Œè¶£å‘³ç«‹ä½“çš„ç«¥çœŸä¸–ç•Œ', tags:['3D','è¶£å‘³'], icon:'ğŸª', rarity:'SR', colors:{ accent:'#ff6b9d', accent2:'#ffa94d', bg:'#0a0510', ground:'#150818' } },
    ];

    document.getElementById('total-styles').textContent = STYLES.length;
    document.getElementById('total-info').textContent = `é£æ ¼å®‡å®™ Â· æ”¶å½• ${STYLES.length} ç§é£æ ¼`;

    // ==================== çŠ¶æ€ç®¡ç† ====================
    let pullCount = 0;
    let collection = [];
    let currentStyle = null;
    let isPulling = false;

    // ==================== Three.js åˆå§‹åŒ– ====================
    const canvas = document.getElementById('canvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#0c0c18');

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
    camera.position.set(0, 8, 35);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.3;

    // åå¤„ç†
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      1.5, 0.4, 0.85
    );
    bloomPass.threshold = 0.15;
    bloomPass.strength = 0.8;
    bloomPass.radius = 0.6;
    composer.addPass(bloomPass);

    // ==================== åœºæ™¯ç»„ ====================
    const worldGroup = new THREE.Group(); // æ•´ä¸ªä¸–ç•Œ
    const groundGroup = new THREE.Group(); // åœ°é¢
    const environmentGroup = new THREE.Group(); // ç¯å¢ƒï¼ˆå¤©ç©ºç­‰ï¼‰
    const installationGroup = new THREE.Group(); // è‰ºæœ¯è£…ç½®
    const particleGroup = new THREE.Group(); // ç²’å­

    scene.add(worldGroup);
    worldGroup.add(groundGroup, environmentGroup, installationGroup, particleGroup);

    // ==================== åœ°é¢ç³»ç»Ÿ ====================
    function createGround(style) {
      // æ¸…ç†
      while (groundGroup.children.length > 0) {
        const child = groundGroup.children[0];
        groundGroup.remove(child);
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      }

      const c = style.colors;
      const accent = new THREE.Color(c.accent);

      // åœ°é¢é¢œè‰²ï¼šåŸºäºaccentè‰²ç”Ÿæˆï¼Œæ¯”èƒŒæ™¯ç¨äº®
      const groundColor = generateStyledBg(c.accent, c.accent2);
      groundColor.multiplyScalar(1.8); // æ¯”èƒŒæ™¯äº®ä¸€äº›

      // åå°„åœ°é¢
      const groundGeo = new THREE.PlaneGeometry(200, 200, 100, 100);
      const groundMat = new THREE.MeshStandardMaterial({
        color: groundColor,
        metalness: 0.4,
        roughness: 0.5,
        transparent: true,
        opacity: 0.4,
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -15;
      groundGroup.add(ground);

      // æ ¹æ®é£æ ¼æ·»åŠ ç‰¹æ®Šåœ°é¢å…ƒç´ 
      if (style.id === 'cyber' || style.id === 'vaporwave' || style.id === 'synthwave') {
        // é€è§†ç½‘æ ¼
        const gridHelper = new THREE.GridHelper(200, 50, accent, accent);
        gridHelper.position.y = -14.9;
        gridHelper.material.opacity = 0.3;
        gridHelper.material.transparent = true;
        groundGroup.add(gridHelper);
      }

      if (style.id === 'matrix' || style.id === 'terminal') {
        const codeGround = new THREE.Mesh(
          new THREE.PlaneGeometry(200, 200),
          new THREE.MeshBasicMaterial({ color: '#001000', transparent: true, opacity: 0.9 })
        );
        codeGround.rotation.x = -Math.PI / 2;
        codeGround.position.y = -14.8;
        groundGroup.add(codeGround);
      }

      if (style.id === 'gothic' || style.id === 'darkacademia') {
        const stoneGround = new THREE.Mesh(
          new THREE.PlaneGeometry(200, 200),
          new THREE.MeshStandardMaterial({ color:'#1a1a1a', metalness:0.2, roughness:0.9, transparent:true, opacity:0.8 })
        );
        stoneGround.rotation.x = -Math.PI / 2;
        stoneGround.position.y = -14.8;
        groundGroup.add(stoneGround);
      }

      if (style.id === 'ocean' || style.id === 'coral' || style.id === 'mediterranean') {
        groundMat.color.set('#051525');
        groundMat.metalness = 0.3;
        groundMat.roughness = 0.7;
      }

      if (style.id === 'desert') {
        groundMat.color.set('#1a1508');
        groundMat.roughness = 0.9;
        groundMat.metalness = 0;
      }

      if (style.id === 'forest' || style.id === 'nature' || style.id === 'solarpunk') {
        groundMat.color.set('#050a05');
        groundMat.roughness = 0.9;
        groundMat.metalness = 0;
      }
    }

    // ==================== ç¯å¢ƒç³»ç»Ÿ ====================
    function createEnvironment(style) {
      while (environmentGroup.children.length > 0) {
        const child = environmentGroup.children[0];
        environmentGroup.remove(child);
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      }

      const c = style.colors;

      // åŸºç¡€ç™½å…‰ï¼ˆä¿è¯æ‰€æœ‰ç‰©ä½“å¯è§ï¼‰
      const ambientWhite = new THREE.AmbientLight('#ffffff', 0.4);
      environmentGroup.add(ambientWhite);

      // é£æ ¼è‰²ç¯å¢ƒå…‰
      const ambientAccent = new THREE.AmbientLight(c.accent, 0.3);
      environmentGroup.add(ambientAccent);

      // ä¸»å…‰æºï¼ˆç™½è‰²åæš–ï¼Œç…§äº®è£…ç½®ï¼‰
      const mainLight = new THREE.DirectionalLight('#fffaf0', 0.6);
      mainLight.position.set(10, 20, 15);
      environmentGroup.add(mainLight);

      // é£æ ¼è‰²ç‚¹å…‰æº
      const pointLight1 = new THREE.PointLight(c.accent, 1.2, 120);
      pointLight1.position.set(20, 15, 20);
      environmentGroup.add(pointLight1);

      const pointLight2 = new THREE.PointLight(c.accent2, 1, 100);
      pointLight2.position.set(-20, 10, -15);
      environmentGroup.add(pointLight2);

      // åº•éƒ¨è¡¥å…‰ï¼ˆå‡å°‘æ­»é»‘é˜´å½±ï¼‰
      const fillLight = new THREE.PointLight('#ffffff', 0.3, 60);
      fillLight.position.set(0, -10, 10);
      environmentGroup.add(fillLight);

      // æ ¹æ®é£æ ¼æ·»åŠ ç‰¹æ®Šç¯å¢ƒ
      if (style.id === 'aurora') {
        // æå…‰å¸˜å¹•
        for (let i = 0; i < 5; i++) {
          const auroraGeo = new THREE.PlaneGeometry(80, 30, 50, 20);
          const auroraMat = new THREE.MeshBasicMaterial({
            color: i % 2 === 0 ? c.accent : c.accent2,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide,
          });
          const aurora = new THREE.Mesh(auroraGeo, auroraMat);
          aurora.position.set(0, 15 + i * 5, -40 - i * 5);
          aurora.userData.phase = i * 0.5;
          aurora.userData.isAurora = true;
          environmentGroup.add(aurora);
        }
      }

      if (style.id === 'sunset') {
        // è½æ—¥
        const sunGeo = new THREE.CircleGeometry(20, 64);
        const sunMat = new THREE.MeshBasicMaterial({
          color: '#ff6347',
          transparent: true,
          opacity: 0.8,
        });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        sun.position.set(0, 5, -60);
        environmentGroup.add(sun);

        // å…‰æ™•
        for (let i = 1; i <= 3; i++) {
          const haloGeo = new THREE.RingGeometry(20 + i * 5, 21 + i * 5, 64);
          const haloMat = new THREE.MeshBasicMaterial({
            color: '#ffd700',
            transparent: true,
            opacity: 0.3 - i * 0.08,
            side: THREE.DoubleSide,
          });
          const halo = new THREE.Mesh(haloGeo, haloMat);
          halo.position.set(0, 5, -59);
          environmentGroup.add(halo);
        }
      }

      if (style.id === 'vaporwave' || style.id === 'synthwave') {
        const vaporSun = new THREE.Mesh(
          new THREE.CircleGeometry(15, 64),
          new THREE.MeshBasicMaterial({ color: style.id === 'vaporwave' ? '#ff71ce' : '#f72585', transparent: true, opacity: 0.7 })
        );
        vaporSun.position.set(0, 8, -50);
        environmentGroup.add(vaporSun);
        for (let i = 0; i < 6; i++) {
          const stripe = new THREE.Mesh(
            new THREE.PlaneGeometry(32, 1.5),
            new THREE.MeshBasicMaterial({ color: '#000', transparent: true, opacity: 0.8 })
          );
          stripe.position.set(0, 8 - i * 2.5, -49);
          environmentGroup.add(stripe);
        }
      }

      // åˆå¤œæ˜Ÿç©º
      if (style.id === 'midnight') {
        const moonGeo = new THREE.CircleGeometry(5, 32);
        const moon = new THREE.Mesh(moonGeo, new THREE.MeshBasicMaterial({ color:'#ffffcc', transparent:true, opacity:0.8 }));
        moon.position.set(15, 20, -50);
        environmentGroup.add(moon);
        const moonGlow = new THREE.Mesh(new THREE.CircleGeometry(8, 32), new THREE.MeshBasicMaterial({ color:'#ffffcc', transparent:true, opacity:0.15 }));
        moonGlow.position.set(15, 20, -51);
        environmentGroup.add(moonGlow);
      }

      // é»æ˜å’Œé»„æ˜
      if (style.id === 'dawn' || style.id === 'dusk' || style.id === 'summer') {
        const dawnSun = new THREE.Mesh(
          new THREE.CircleGeometry(12, 64),
          new THREE.MeshBasicMaterial({ color: c.accent, transparent:true, opacity:0.6 })
        );
        dawnSun.position.set(0, style.id === 'dawn' ? -5 : 3, -55);
        environmentGroup.add(dawnSun);
        for (let i = 1; i <= 4; i++) {
          const halo = new THREE.Mesh(
            new THREE.RingGeometry(12 + i * 4, 13 + i * 4, 64),
            new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.2 - i * 0.04, side:THREE.DoubleSide })
          );
          halo.position.set(0, style.id === 'dawn' ? -5 : 3, -54);
          environmentGroup.add(halo);
        }
      }

      // æ£®æ—ï¼šç»¿è‰²ç¯å¢ƒå…‰
      if (style.id === 'forest') {
        const fogLight = new THREE.PointLight('#228b22', 0.5, 50);
        fogLight.position.set(0, 5, 0);
        environmentGroup.add(fogLight);
      }

      // æš´é£ï¼šé—ªç”µå…‰
      if (style.id === 'stormy') {
        const lightningLight = new THREE.PointLight('#ffd700', 0, 100);
        lightningLight.position.set(0, 20, -10);
        lightningLight.userData.isLightning = true;
        environmentGroup.add(lightningLight);
      }

      // ç¦…æ„ï¼šæç®€
      if (style.id === 'zen') {
        const stone1 = new THREE.Mesh(
          new THREE.SphereGeometry(2, 8, 8),
          new THREE.MeshStandardMaterial({ color:'#696969', roughness:0.9 })
        );
        stone1.position.set(-3, -13, -5);
        stone1.scale.y = 0.7;
        environmentGroup.add(stone1);
        const stone2 = new THREE.Mesh(
          new THREE.SphereGeometry(1.2, 8, 8),
          new THREE.MeshStandardMaterial({ color:'#808080', roughness:0.9 })
        );
        stone2.position.set(4, -13.5, -3);
        stone2.scale.y = 0.6;
        environmentGroup.add(stone2);
      }
    }

    // ==================== è‰ºæœ¯è£…ç½®ç³»ç»Ÿ ====================
    function createInstallation(style) {
      while (installationGroup.children.length > 0) {
        const child = installationGroup.children[0];
        installationGroup.remove(child);
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      }

      const c = style.colors;
      const accent = new THREE.Color(c.accent);
      const accent2 = new THREE.Color(c.accent2);

      switch (style.id) {
        case 'glass':
          // å¤šå±‚ç»ç’ƒçƒä½“åµŒå¥—
          for (let i = 0; i < 5; i++) {
            const sphere = new THREE.Mesh(
              new THREE.IcosahedronGeometry(6 - i, i < 2 ? 2 : 1),
              new THREE.MeshPhysicalMaterial({
                color: accent.clone().lerp(accent2, i / 4),
                metalness: 0.1,
                roughness: 0.1,
                transparent: true,
                opacity: 0.3,
                wireframe: i % 2 === 1,
              })
            );
            sphere.userData.rotSpeed = 0.002 * (i + 1) * (i % 2 === 0 ? 1 : -1);
            sphere.userData.isInstallation = true;
            installationGroup.add(sphere);
          }
          break;

        case 'neon':
          // éœ“è™¹ç¯ç®¡é›•å¡‘
          const neonShapes = [
            { type: 'torus', args: [8, 0.3, 16, 100], pos: [0, 0, 0], rot: [Math.PI / 2, 0, 0] },
            { type: 'torus', args: [6, 0.3, 16, 100], pos: [0, 0, 0], rot: [Math.PI / 3, Math.PI / 4, 0] },
            { type: 'torus', args: [4, 0.3, 16, 100], pos: [0, 0, 0], rot: [Math.PI / 4, Math.PI / 2, 0] },
          ];
          neonShapes.forEach((s, i) => {
            const geo = new THREE.TorusGeometry(...s.args);
            const mat = new THREE.MeshBasicMaterial({
              color: i % 2 === 0 ? c.accent : c.accent2,
              transparent: true,
              opacity: 0.9,
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(...s.pos);
            mesh.rotation.set(...s.rot);
            mesh.userData.rotSpeed = 0.01 * (i + 1);
            mesh.userData.rotAxis = ['x', 'y', 'z'][i % 3];
            mesh.userData.isInstallation = true;
            installationGroup.add(mesh);
          });
          // å‘å…‰æ ¸å¿ƒ
          const neonCore = new THREE.Mesh(
            new THREE.SphereGeometry(2, 32, 32),
            new THREE.MeshBasicMaterial({ color: '#ffffff' })
          );
          neonCore.userData.isInstallation = true;
          installationGroup.add(neonCore);
          break;

        case 'cyber':
          // æ•°æ®ç«‹æ–¹ä½“
          const cubeGroup = new THREE.Group();
          for (let i = 0; i < 3; i++) {
            const cube = new THREE.Mesh(
              new THREE.BoxGeometry(8 - i * 2, 8 - i * 2, 8 - i * 2),
              new THREE.MeshBasicMaterial({
                color: i === 0 ? c.accent : c.accent2,
                wireframe: true,
                transparent: true,
                opacity: 0.6,
              })
            );
            cube.userData.rotSpeed = 0.005 * (i + 1);
            cubeGroup.add(cube);
          }
          cubeGroup.userData.isInstallation = true;
          cubeGroup.userData.rotSpeed = 0.003;
          installationGroup.add(cubeGroup);
          // æ•°æ®æµç²’å­
          const dataCount = 200;
          const dataGeo = new THREE.BufferGeometry();
          const dataPos = new Float32Array(dataCount * 3);
          for (let i = 0; i < dataCount; i++) {
            dataPos[i * 3] = (Math.random() - 0.5) * 12;
            dataPos[i * 3 + 1] = (Math.random() - 0.5) * 12;
            dataPos[i * 3 + 2] = (Math.random() - 0.5) * 12;
          }
          dataGeo.setAttribute('position', new THREE.BufferAttribute(dataPos, 3));
          const dataPoints = new THREE.Points(dataGeo, new THREE.PointsMaterial({
            color: c.accent,
            size: 0.15,
            transparent: true,
            opacity: 0.8,
          }));
          dataPoints.userData.isData = true;
          installationGroup.add(dataPoints);
          break;

        case 'aurora':
          // æå…‰æ³¢åŠ¨å¸¦
          for (let i = 0; i < 8; i++) {
            const waveGeo = new THREE.PlaneGeometry(40, 8, 80, 16);
            const waveMat = new THREE.MeshBasicMaterial({
              color: i % 2 === 0 ? c.accent : c.accent2,
              transparent: true,
              opacity: 0.25,
              side: THREE.DoubleSide,
              wireframe: i % 3 === 0,
            });
            const wave = new THREE.Mesh(waveGeo, waveMat);
            wave.position.y = i * 2 - 4;
            wave.rotation.x = -0.3;
            wave.userData.wavePhase = i * 0.5;
            wave.userData.isWave = true;
            installationGroup.add(wave);
          }
          break;

        case 'japanese':
          // æ¨±èŠ±æ ‘
          const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.5, 12, 8),
            new THREE.MeshStandardMaterial({ color: '#4a3728', roughness: 0.9 })
          );
          trunk.position.y = -9;
          installationGroup.add(trunk);
          // æ ‘å† ï¼ˆç²‰è‰²çƒï¼‰
          for (let i = 0; i < 15; i++) {
            const branch = new THREE.Mesh(
              new THREE.SphereGeometry(2 + Math.random() * 2, 8, 8),
              new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? c.accent : c.accent2,
                transparent: true,
                opacity: 0.6,
              })
            );
            branch.position.set(
              (Math.random() - 0.5) * 8,
              (Math.random() - 0.5) * 6,
              (Math.random() - 0.5) * 8
            );
            installationGroup.add(branch);
          }
          break;

        case 'gothic':
          // å“¥ç‰¹å°–å¡”
          for (let i = 0; i < 5; i++) {
            const spire = new THREE.Mesh(
              new THREE.ConeGeometry(1.5, 15 + i * 3, 4),
              new THREE.MeshStandardMaterial({
                color: i === 2 ? c.accent : '#1a1a1a',
                metalness: 0.5,
                roughness: 0.5,
              })
            );
            spire.position.set((i - 2) * 5, -7 + i * 1.5, 0);
            installationGroup.add(spire);
          }
          // å‘å…‰ç¬¦æ–‡ç¯
          const runeRing = new THREE.Mesh(
            new THREE.TorusGeometry(10, 0.2, 16, 100),
            new THREE.MeshBasicMaterial({ color: c.accent })
          );
          runeRing.rotation.x = Math.PI / 2;
          runeRing.position.y = -10;
          runeRing.userData.isInstallation = true;
          runeRing.userData.rotSpeed = 0.01;
          installationGroup.add(runeRing);
          break;

        case 'vaporwave':
          // å¸Œè…Šé›•åƒç¢ç‰‡
          const statueBase = new THREE.Group();
          // èº¯å¹²
          const torso = new THREE.Mesh(
            new THREE.CylinderGeometry(2, 2.5, 8, 8),
            new THREE.MeshStandardMaterial({ color: '#e0e0e0', roughness: 0.4 })
          );
          statueBase.add(torso);
          // å¤´éƒ¨
          const head = new THREE.Mesh(
            new THREE.SphereGeometry(1.5, 16, 16),
            new THREE.MeshStandardMaterial({ color: '#e0e0e0', roughness: 0.4 })
          );
          head.position.y = 5.5;
          statueBase.add(head);
          statueBase.rotation.y = Math.PI / 6;
          statueBase.position.y = -6;
          statueBase.userData.isInstallation = true;
          statueBase.userData.floatPhase = 0;
          installationGroup.add(statueBase);
          break;

        case 'pixel':
          // åƒç´ æ–¹å—ç¾¤
          for (let i = 0; i < 50; i++) {
            const size = 1 + Math.floor(Math.random() * 3);
            const pixelCube = new THREE.Mesh(
              new THREE.BoxGeometry(size, size, size),
              new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? c.accent : c.accent2,
                transparent: true,
                opacity: 0.7,
              })
            );
            pixelCube.position.set(
              Math.round((Math.random() - 0.5) * 20),
              Math.round((Math.random() - 0.5) * 15),
              Math.round((Math.random() - 0.5) * 15)
            );
            pixelCube.userData.floatSpeed = Math.random() * 0.02;
            pixelCube.userData.floatPhase = Math.random() * Math.PI * 2;
            installationGroup.add(pixelCube);
          }
          break;

        case 'glitch':
          // æ•…éšœç«‹æ–¹ä½“
          const glitchGroup = new THREE.Group();
          for (let i = 0; i < 3; i++) {
            const glitchCube = new THREE.Mesh(
              new THREE.BoxGeometry(6, 6, 6),
              new THREE.MeshBasicMaterial({
                color: ['#ff0000', '#00ff00', '#0000ff'][i],
                transparent: true,
                opacity: 0.5,
                wireframe: i === 1,
              })
            );
            glitchCube.position.x = (i - 1) * 0.5;
            glitchCube.userData.glitchOffset = i;
            glitchGroup.add(glitchCube);
          }
          glitchGroup.userData.isGlitch = true;
          installationGroup.add(glitchGroup);
          break;

        case 'matrix':
          // ä»£ç çƒä½“
          const codeSphere = new THREE.Mesh(
            new THREE.SphereGeometry(8, 32, 32),
            new THREE.MeshBasicMaterial({
              color: c.accent,
              wireframe: true,
              transparent: true,
              opacity: 0.5,
            })
          );
          codeSphere.userData.isInstallation = true;
          codeSphere.userData.rotSpeed = 0.005;
          installationGroup.add(codeSphere);
          // å†…æ ¸
          const codeCore = new THREE.Mesh(
            new THREE.OctahedronGeometry(3, 0),
            new THREE.MeshBasicMaterial({ color: c.accent })
          );
          codeCore.userData.isInstallation = true;
          codeCore.userData.rotSpeed = -0.01;
          installationGroup.add(codeCore);
          break;

        case 'holographic': {
          // å½©è™¹æ£±é•œ
          const prism = new THREE.Mesh(
            new THREE.ConeGeometry(5, 10, 3),
            new THREE.MeshPhysicalMaterial({ color:'#ffffff', metalness:0.9, roughness:0, transparent:true, opacity:0.5 })
          );
          prism.userData.isInstallation = true;
          prism.userData.rotSpeed = 0.008;
          installationGroup.add(prism);
          // å½©è™¹å…‰ç¯
          const rainbowColors = ['#ff0000','#ff8c00','#ffd700','#00ff00','#0099ff','#6600cc'];
          rainbowColors.forEach((rc, i) => {
            const rr = new THREE.Mesh(
              new THREE.TorusGeometry(7 + i * 1.2, 0.15, 16, 100),
              new THREE.MeshBasicMaterial({ color:rc, transparent:true, opacity:0.5 })
            );
            rr.rotation.x = Math.PI / 2 + i * 0.05;
            rr.rotation.z = i * 0.1;
            rr.userData.isInstallation = true;
            rr.userData.rotSpeed = 0.003 * (i + 1);
            installationGroup.add(rr);
          });
          break;
        }
        case 'chinese': {
          // ç›˜æ—‹é‡‘é¾™ï¼ˆèºæ—‹ï¼‰
          const dragonGroup = new THREE.Group();
          for (let i = 0; i < 80; i++) {
            const t = i * 0.15;
            const x = Math.cos(t) * (5 + t * 0.2);
            const y = t * 0.6 - 8;
            const z = Math.sin(t) * (5 + t * 0.2);
            const seg = new THREE.Mesh(
              new THREE.SphereGeometry(0.6 - i * 0.004, 8, 8),
              new THREE.MeshBasicMaterial({ color: i < 5 ? c.accent2 : c.accent, transparent:true, opacity:0.8 })
            );
            seg.position.set(x, y, z);
            dragonGroup.add(seg);
          }
          dragonGroup.userData.isInstallation = true;
          dragonGroup.userData.rotSpeed = 0.005;
          installationGroup.add(dragonGroup);
          break;
        }
        case 'ocean': {
          // æ°´æ¯ç¾¤
          for (let j = 0; j < 6; j++) {
            const jelly = new THREE.Group();
            const cap = new THREE.Mesh(
              new THREE.SphereGeometry(2, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2),
              new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.5 })
            );
            jelly.add(cap);
            for (let t = 0; t < 8; t++) {
              const tentacle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 4 + Math.random() * 3, 4),
                new THREE.MeshBasicMaterial({ color: c.accent, transparent:true, opacity:0.4 })
              );
              tentacle.position.set(Math.cos(t * Math.PI / 4) * 1.2, -3, Math.sin(t * Math.PI / 4) * 1.2);
              tentacle.userData.tentaclePhase = t;
              jelly.add(tentacle);
            }
            jelly.position.set((Math.random() - 0.5) * 25, Math.random() * 15 - 5, (Math.random() - 0.5) * 20);
            jelly.userData.floatPhase = Math.random() * Math.PI * 2;
            jelly.userData.floatSpeed = 0.005 + Math.random() * 0.01;
            jelly.userData.isJellyfish = true;
            installationGroup.add(jelly);
          }
          break;
        }
        case 'steampunk': {
          // é½¿è½®ç»„
          for (let i = 0; i < 6; i++) {
            const gear = new THREE.Mesh(
              new THREE.TorusGeometry(3 + i * 1.5, 0.6, 8, i < 3 ? 12 : 16),
              new THREE.MeshStandardMaterial({ color: i % 2 === 0 ? c.accent : c.accent2, metalness:0.9, roughness:0.2 })
            );
            gear.position.set((i - 2.5) * 4, (i % 3 - 1) * 3, 0);
            gear.rotation.set(0, 0, i * 0.3);
            gear.userData.isInstallation = true;
            gear.userData.rotSpeed = 0.008 * (i % 2 === 0 ? 1 : -1);
            gear.userData.rotAxis = 'z';
            installationGroup.add(gear);
          }
          break;
        }
        case 'romantic': {
          // å·¨å¤§æ°´æ™¶å¿ƒå½¢
          const heartShape = new THREE.Shape();
          heartShape.moveTo(0, 2);
          heartShape.bezierCurveTo(2, 4, 4, 2, 4, 0);
          heartShape.bezierCurveTo(4, -2, 2, -4, 0, -5);
          heartShape.bezierCurveTo(-2, -4, -4, -2, -4, 0);
          heartShape.bezierCurveTo(-4, 2, -2, 4, 0, 2);
          const heartGeo = new THREE.ExtrudeGeometry(heartShape, { depth:1, bevelEnabled:true, bevelThickness:0.5, bevelSize:0.5, bevelSegments:3 });
          const heartMesh = new THREE.Mesh(heartGeo, new THREE.MeshPhysicalMaterial({
            color: c.accent, metalness:0.3, roughness:0.2, transparent:true, opacity:0.7
          }));
          heartMesh.scale.set(1.2, 1.2, 1.2);
          heartMesh.userData.isInstallation = true;
          heartMesh.userData.rotSpeed = 0.005;
          installationGroup.add(heartMesh);
          break;
        }
        case 'synthwave': {
          // éœ“è™¹å±±è„‰
          const mountainGeo = new THREE.PlaneGeometry(60, 30, 30, 15);
          const pos = mountainGeo.attributes.position;
          for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i);
            const y = pos.getY(i);
            pos.setZ(i, Math.sin(x * 0.15) * 3 + Math.sin(y * 0.3) * 2 + Math.random() * 0.5);
          }
          const mountain = new THREE.Mesh(mountainGeo, new THREE.MeshBasicMaterial({
            color: c.accent, wireframe:true, transparent:true, opacity:0.5
          }));
          mountain.rotation.x = -0.6;
          mountain.position.set(0, -5, -20);
          installationGroup.add(mountain);
          break;
        }
        case 'ios': {
          // è‹¹æœé£æ ¼å›¾æ ‡
          for (let i = 0; i < 9; i++) {
            const icon = new THREE.Mesh(
              new THREE.BoxGeometry(3, 3, 0.5),
              new THREE.MeshStandardMaterial({
                color: ['#007aff','#34c759','#ff3b30','#ff9500','#af52de','#5856d6','#ff2d55','#00c7be','#007aff'][i],
                metalness:0.2, roughness:0.5,
              })
            );
            icon.position.set(((i % 3) - 1) * 4.5, (Math.floor(i / 3) - 1) * 4.5, 0);
            icon.userData.isInstallation = true;
            icon.userData.floatPhase = i * 0.5;
            icon.userData.floatSpeed = 0.01;
            installationGroup.add(icon);
          }
          break;
        }
        case 'spotify': {
          // é»‘èƒ¶å”±ç‰‡
          const vinyl = new THREE.Mesh(
            new THREE.CylinderGeometry(7, 7, 0.3, 64),
            new THREE.MeshStandardMaterial({ color:'#111', metalness:0.9, roughness:0.15 })
          );
          vinyl.rotation.x = Math.PI / 6;
          vinyl.userData.isInstallation = true;
          vinyl.userData.rotSpeed = 0.02;
          installationGroup.add(vinyl);
          for (let i = 1; i < 7; i++) {
            const groove = new THREE.Mesh(
              new THREE.TorusGeometry(i, 0.03, 8, 100),
              new THREE.MeshBasicMaterial({ color:'#222' })
            );
            groove.rotation.x = Math.PI / 6;
            groove.position.z = 0.16;
            groove.userData.isInstallation = true;
            groove.userData.rotSpeed = 0.02;
            installationGroup.add(groove);
          }
          const label = new THREE.Mesh(
            new THREE.CircleGeometry(2, 32),
            new THREE.MeshBasicMaterial({ color: c.accent })
          );
          label.rotation.x = -Math.PI / 2 + Math.PI / 6;
          label.position.y = 0.16;
          label.userData.isInstallation = true;
          label.userData.rotSpeed = 0.02;
          installationGroup.add(label);
          break;
        }
        case 'indian': {
          // æ›¼é™€ç½—
          const mandala = new THREE.Group();
          for (let layer = 0; layer < 6; layer++) {
            const petals = 8 + layer * 4;
            for (let i = 0; i < petals; i++) {
              const angle = (i / petals) * Math.PI * 2;
              const r = 2 + layer * 2;
              const p = new THREE.Mesh(
                new THREE.CircleGeometry(0.8 + layer * 0.1, 6),
                new THREE.MeshBasicMaterial({ color: layer % 2 === 0 ? c.accent : c.accent2, transparent:true, opacity:0.6, side:THREE.DoubleSide })
              );
              p.position.set(Math.cos(angle) * r, Math.sin(angle) * r, layer * 0.1);
              p.rotation.z = angle;
              mandala.add(p);
            }
          }
          mandala.userData.isInstallation = true;
          mandala.userData.rotSpeed = 0.003;
          mandala.userData.rotAxis = 'z';
          installationGroup.add(mandala);
          break;
        }
        case 'arabian': {
          // é˜¿æ‹‰ä¸ç¥ç¯ + é‡‘çƒŸ
          const lampBody = new THREE.Group();
          const base = new THREE.Mesh(
            new THREE.LatheGeometry([
              new THREE.Vector2(0, 0), new THREE.Vector2(1.5, 0.5), new THREE.Vector2(2, 1),
              new THREE.Vector2(1.8, 2), new THREE.Vector2(0.5, 2.5), new THREE.Vector2(0.3, 3),
            ], 32),
            new THREE.MeshStandardMaterial({ color: c.accent2, metalness:0.9, roughness:0.1 })
          );
          base.scale.set(2, 2, 2);
          base.position.y = -8;
          lampBody.add(base);
          // é‡‘è‰²çƒŸé›¾
          const smokeGeo = new THREE.BufferGeometry();
          const smokePos = new Float32Array(200 * 3);
          for (let i = 0; i < 200; i++) {
            const t = i / 200;
            smokePos[i * 3] = (Math.random() - 0.5) * (2 + t * 4);
            smokePos[i * 3 + 1] = t * 15 - 2;
            smokePos[i * 3 + 2] = (Math.random() - 0.5) * (2 + t * 4);
          }
          smokeGeo.setAttribute('position', new THREE.BufferAttribute(smokePos, 3));
          const smoke = new THREE.Points(smokeGeo, new THREE.PointsMaterial({
            color: c.accent2, size:0.4, transparent:true, opacity:0.5, blending:THREE.AdditiveBlending
          }));
          smoke.userData.isSmoke = true;
          lampBody.add(smoke);
          installationGroup.add(lampBody);
          break;
        }
        case 'watercolor': {
          // æ°´å½©äº‘å›¢
          for (let i = 0; i < 12; i++) {
            const cloud = new THREE.Mesh(
              new THREE.SphereGeometry(2 + Math.random() * 3, 8, 8),
              new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? c.accent : c.accent2, transparent:true, opacity:0.25 + Math.random() * 0.15
              })
            );
            cloud.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 12, (Math.random() - 0.5) * 15);
            cloud.scale.set(1 + Math.random(), 0.5 + Math.random() * 0.5, 1 + Math.random());
            cloud.userData.isInstallation = true;
            cloud.userData.floatPhase = Math.random() * Math.PI * 2;
            cloud.userData.floatSpeed = 0.005;
            installationGroup.add(cloud);
          }
          break;
        }
        case 'memphis': {
          // å­Ÿè²æ–¯å‡ ä½•ç»„åˆ
          const geos = [
            () => new THREE.ConeGeometry(2, 4, 3),
            () => new THREE.SphereGeometry(2, 16, 16),
            () => new THREE.BoxGeometry(3, 3, 3),
            () => new THREE.TorusGeometry(2, 0.5, 8, 20),
            () => new THREE.CylinderGeometry(0.3, 0.3, 6, 8),
          ];
          const memColors = ['#ff6b6b','#4ecdc4','#ffd93d','#6c5ce7','#fd79a8'];
          for (let i = 0; i < 15; i++) {
            const mesh = new THREE.Mesh(
              geos[i % geos.length](),
              new THREE.MeshBasicMaterial({ color: memColors[i % memColors.length], transparent:true, opacity:0.7 })
            );
            mesh.position.set((Math.random() - 0.5) * 25, (Math.random() - 0.5) * 18, (Math.random() - 0.5) * 15);
            mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            mesh.userData.isInstallation = true;
            mesh.userData.rotSpeed = (Math.random() - 0.5) * 0.01;
            installationGroup.add(mesh);
          }
          break;
        }
        case 'bauhaus': {
          // ä¸‰åŸè‰²å‡ ä½•
          const shapes = [
            { geo: new THREE.CircleGeometry(4, 32), color:'#e63946', y:4, side:THREE.DoubleSide },
            { geo: new THREE.BoxGeometry(6, 6, 0.2), color:'#457b9d', y:-2 },
            { geo: new THREE.ConeGeometry(4, 7, 3), color:'#f1faee', y:0 },
          ];
          shapes.forEach((s, i) => {
            const mesh = new THREE.Mesh(s.geo, new THREE.MeshBasicMaterial({ color:s.color, transparent:true, opacity:0.8, side:s.side || THREE.FrontSide }));
            mesh.position.set((i - 1) * 8, s.y, 0);
            mesh.userData.isInstallation = true;
            mesh.userData.rotSpeed = 0.003;
            installationGroup.add(mesh);
          });
          break;
        }
        case 'popart': {
          // æ³¢æ™®é‡å¤åœ†ç‚¹
          for (let i = 0; i < 30; i++) {
            const dot = new THREE.Mesh(
              new THREE.CircleGeometry(0.5 + Math.random() * 1.5, 16),
              new THREE.MeshBasicMaterial({
                color: ['#ff1493','#00ff00','#ffff00','#ff4500','#00bfff'][i % 5],
                transparent:true, opacity:0.7, side:THREE.DoubleSide
              })
            );
            dot.position.set((Math.random() - 0.5) * 30, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 10);
            installationGroup.add(dot);
          }
          break;
        }
        case 'gaming': {
          // æ¸¸æˆæ‰‹æŸ„å½¢æ€
          const padGroup = new THREE.Group();
          const padBody = new THREE.Mesh(
            new THREE.BoxGeometry(10, 6, 2, 4, 4, 1),
            new THREE.MeshStandardMaterial({ color:'#1a1a2e', metalness:0.5, roughness:0.3 })
          );
          padGroup.add(padBody);
          // æŒ‰é’®
          const btnColors = [c.accent, c.accent2, '#ff0000', '#00ff00'];
          btnColors.forEach((bc, i) => {
            const btn = new THREE.Mesh(
              new THREE.SphereGeometry(0.5, 16, 16),
              new THREE.MeshBasicMaterial({ color:bc })
            );
            btn.position.set(3 + (i % 2), 1 - Math.floor(i / 2), 1.2);
            padGroup.add(btn);
          });
          padGroup.userData.isInstallation = true;
          padGroup.userData.rotSpeed = 0.005;
          installationGroup.add(padGroup);
          break;
        }
        case 'music': {
          // éŸ³æ³¢å¯è§†åŒ–
          for (let i = 0; i < 48; i++) {
            const h = 3 + Math.random() * 10;
            const bar = new THREE.Mesh(
              new THREE.BoxGeometry(0.6, h, 0.6),
              new THREE.MeshBasicMaterial({ color: i % 2 ? c.accent : c.accent2, transparent:true, opacity:0.7 })
            );
            bar.position.set(i * 0.8 - 19, h / 2 - 8, 0);
            bar.userData.baseHeight = h;
            bar.userData.barPhase = i * 0.2;
            bar.userData.isBar = true;
            installationGroup.add(bar);
          }
          break;
        }
        case 'marble': {
          // å¤§ç†çŸ³é›•å¡‘
          const sculpture = new THREE.Mesh(
            new THREE.DodecahedronGeometry(6, 1),
            new THREE.MeshStandardMaterial({ color:'#e8e8e8', metalness:0.1, roughness:0.3 })
          );
          sculpture.userData.isInstallation = true;
          sculpture.userData.rotSpeed = 0.002;
          installationGroup.add(sculpture);
          const pedestal = new THREE.Mesh(
            new THREE.CylinderGeometry(3, 4, 3, 8),
            new THREE.MeshStandardMaterial({ color:'#d0d0d0', metalness:0.1, roughness:0.3 })
          );
          pedestal.position.y = -10;
          installationGroup.add(pedestal);
          break;
        }
        case 'metal': {
          // æ¶²æ€é‡‘å±çƒ
          const metalSphere = new THREE.Mesh(
            new THREE.IcosahedronGeometry(6, 4),
            new THREE.MeshStandardMaterial({ color:'#b0b0b0', metalness:1, roughness:0 })
          );
          metalSphere.userData.isInstallation = true;
          metalSphere.userData.rotSpeed = 0.003;
          metalSphere.userData.isMetal = true;
          installationGroup.add(metalSphere);
          break;
        }
        case 'fashion': {
          // Tå°èšå…‰ç¯
          for (let i = 0; i < 6; i++) {
            const spotlight = new THREE.Mesh(
              new THREE.ConeGeometry(3, 30, 16, 1, true),
              new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.08, side:THREE.DoubleSide })
            );
            spotlight.position.set((i - 2.5) * 6, 15, -5);
            spotlight.rotation.x = Math.PI;
            installationGroup.add(spotlight);
          }
          // äººå½¢å‰ªå½±
          const silhouette = new THREE.Mesh(
            new THREE.CylinderGeometry(1, 1.5, 10, 8),
            new THREE.MeshBasicMaterial({ color:'#000', transparent:true, opacity:0.8 })
          );
          silhouette.position.y = -5;
          const sHead = new THREE.Mesh(
            new THREE.SphereGeometry(1.2, 16, 16),
            new THREE.MeshBasicMaterial({ color:'#000', transparent:true, opacity:0.8 })
          );
          sHead.position.y = 1;
          silhouette.add(sHead);
          installationGroup.add(silhouette);
          break;
        }
        case 'finance': {
          // Kçº¿å›¾
          for (let i = 0; i < 20; i++) {
            const h = 2 + Math.random() * 10;
            const isUp = Math.random() > 0.4;
            const candle = new THREE.Mesh(
              new THREE.BoxGeometry(0.8, h, 0.8),
              new THREE.MeshBasicMaterial({ color: isUp ? c.accent : c.accent2, transparent:true, opacity:0.8 })
            );
            candle.position.set(i * 1.5 - 15, h / 2 - 10, 0);
            // å½±çº¿
            const wick = new THREE.Mesh(
              new THREE.BoxGeometry(0.1, h + 3, 0.1),
              new THREE.MeshBasicMaterial({ color: isUp ? c.accent : c.accent2, transparent:true, opacity:0.5 })
            );
            wick.position.set(i * 1.5 - 15, h / 2 - 10, 0);
            installationGroup.add(candle, wick);
          }
          break;
        }
        case 'travel': {
          // åœ°çƒä»ª
          const globe = new THREE.Mesh(
            new THREE.SphereGeometry(6, 32, 32),
            new THREE.MeshBasicMaterial({ color: c.accent, wireframe:true, transparent:true, opacity:0.4 })
          );
          globe.userData.isInstallation = true;
          globe.userData.rotSpeed = 0.003;
          installationGroup.add(globe);
          // é£è¡Œè·¯å¾„ç¯
          for (let i = 0; i < 3; i++) {
            const path = new THREE.Mesh(
              new THREE.TorusGeometry(7 + i, 0.05, 8, 100),
              new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.5 })
            );
            path.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
            path.userData.isInstallation = true;
            path.userData.rotSpeed = 0.005 + i * 0.002;
            installationGroup.add(path);
          }
          break;
        }
        case 'weirdcore': {
          // æ‰­æ›²çš„çœ¼ç›å’Œé—¨
          for (let i = 0; i < 8; i++) {
            const eye = new THREE.Group();
            const white = new THREE.Mesh(
              new THREE.SphereGeometry(1.5, 16, 16),
              new THREE.MeshBasicMaterial({ color:'#fff' })
            );
            const pupil = new THREE.Mesh(
              new THREE.SphereGeometry(0.6, 16, 16),
              new THREE.MeshBasicMaterial({ color:'#000' })
            );
            pupil.position.z = 1;
            eye.add(white, pupil);
            eye.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
            eye.scale.setScalar(0.5 + Math.random() * 1);
            eye.userData.lookPhase = Math.random() * Math.PI * 2;
            eye.userData.isEye = true;
            installationGroup.add(eye);
          }
          break;
        }
        case 'dreamcore': {
          // æ¼‚æµ®çš„é—¨å’Œæ¥¼æ¢¯
          for (let i = 0; i < 4; i++) {
            const door = new THREE.Mesh(
              new THREE.BoxGeometry(3, 5, 0.3),
              new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? c.accent : c.accent2, transparent:true, opacity:0.5 })
            );
            door.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 15);
            door.rotation.y = Math.random() * Math.PI;
            door.userData.floatPhase = Math.random() * Math.PI * 2;
            door.userData.floatSpeed = 0.005 + Math.random() * 0.005;
            installationGroup.add(door);
          }
          // æ¼‚æµ®æ¥¼æ¢¯
          for (let i = 0; i < 10; i++) {
            const step = new THREE.Mesh(
              new THREE.BoxGeometry(3, 0.3, 1.5),
              new THREE.MeshBasicMaterial({ color: c.accent, transparent:true, opacity:0.4 })
            );
            step.position.set(Math.sin(i * 0.5) * 3, i * 1.5 - 8, Math.cos(i * 0.5) * 3);
            installationGroup.add(step);
          }
          break;
        }
        case 'solarpunk': {
          // æœªæ¥ç»¿è‰²åŸå¸‚
          for (let i = 0; i < 8; i++) {
            const building = new THREE.Mesh(
              new THREE.CylinderGeometry(1 + Math.random(), 1.5 + Math.random(), 5 + Math.random() * 10, 8),
              new THREE.MeshStandardMaterial({ color: i % 2 === 0 ? c.accent : c.accent2, metalness:0.3, roughness:0.5 })
            );
            building.position.set((Math.random() - 0.5) * 20, -10 + building.geometry.parameters.height / 2, (Math.random() - 0.5) * 15);
            installationGroup.add(building);
            // æ¤ç‰©çƒ
            const plant = new THREE.Mesh(
              new THREE.SphereGeometry(1 + Math.random(), 8, 8),
              new THREE.MeshBasicMaterial({ color:'#228b22', transparent:true, opacity:0.6 })
            );
            plant.position.copy(building.position);
            plant.position.y += building.geometry.parameters.height / 2 + 1;
            installationGroup.add(plant);
          }
          break;
        }
        case 'darkacademia': {
          // ä¹¦æ¶
          for (let i = 0; i < 5; i++) {
            const shelf = new THREE.Mesh(
              new THREE.BoxGeometry(12, 0.3, 2),
              new THREE.MeshStandardMaterial({ color:'#3c2415', roughness:0.8 })
            );
            shelf.position.set(0, i * 3 - 8, -5);
            installationGroup.add(shelf);
            // ä¹¦æœ¬
            for (let b = 0; b < 8; b++) {
              const book = new THREE.Mesh(
                new THREE.BoxGeometry(0.5 + Math.random() * 0.3, 2, 1.5),
                new THREE.MeshBasicMaterial({ color: ['#8b0000','#006400','#00008b','#4b0082','#8b4513'][Math.floor(Math.random() * 5)] })
              );
              book.position.set(b * 1.4 - 5, i * 3 - 7, -5);
              installationGroup.add(book);
            }
          }
          // èœ¡çƒ›
          const candle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 2, 8),
            new THREE.MeshBasicMaterial({ color:'#f5deb3' })
          );
          candle.position.set(5, -5, 0);
          installationGroup.add(candle);
          const flame = new THREE.Mesh(
            new THREE.ConeGeometry(0.15, 0.5, 8),
            new THREE.MeshBasicMaterial({ color:'#ff8c00' })
          );
          flame.position.set(5, -3.7, 0);
          flame.userData.isFlame = true;
          installationGroup.add(flame);
          break;
        }
        case 'victorian': {
          // åä¸½é‡‘è‰²ç›¸æ¡†
          const frame = new THREE.Group();
          const outerFrame = new THREE.Mesh(
            new THREE.BoxGeometry(12, 16, 1),
            new THREE.MeshStandardMaterial({ color: c.accent2, metalness:0.8, roughness:0.2 })
          );
          frame.add(outerFrame);
          const innerCut = new THREE.Mesh(
            new THREE.BoxGeometry(9, 13, 1.1),
            new THREE.MeshBasicMaterial({ color: '#1a0010' })
          );
          frame.add(innerCut);
          // è£…é¥°è§’
          for (let cx = -1; cx <= 1; cx += 2) {
            for (let cy = -1; cy <= 1; cy += 2) {
              const corner = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 8, 8),
                new THREE.MeshStandardMaterial({ color: c.accent2, metalness:0.9, roughness:0.1 })
              );
              corner.position.set(cx * 5.5, cy * 7.5, 0.5);
              frame.add(corner);
            }
          }
          frame.userData.isInstallation = true;
          frame.userData.floatPhase = 0;
          frame.userData.floatSpeed = 0.003;
          installationGroup.add(frame);
          break;
        }
        case 'stormy': {
          // æ¼©æ¶¡äº‘
          const vortex = new THREE.Group();
          for (let i = 0; i < 30; i++) {
            const t = i / 30;
            const angle = t * Math.PI * 6;
            const r = t * 12;
            const cloud = new THREE.Mesh(
              new THREE.SphereGeometry(1 + t * 2, 8, 8),
              new THREE.MeshBasicMaterial({ color: i % 3 === 0 ? c.accent2 : '#333', transparent:true, opacity:0.4 })
            );
            cloud.position.set(Math.cos(angle) * r, 5, Math.sin(angle) * r);
            vortex.add(cloud);
          }
          vortex.userData.isInstallation = true;
          vortex.userData.rotSpeed = 0.01;
          installationGroup.add(vortex);
          break;
        }
        case 'frutiger': {
          // é€æ˜æ°”æ³¡
          for (let i = 0; i < 15; i++) {
            const bubble = new THREE.Mesh(
              new THREE.SphereGeometry(1 + Math.random() * 3, 32, 32),
              new THREE.MeshPhysicalMaterial({
                color: i % 2 === 0 ? c.accent : c.accent2,
                metalness:0, roughness:0, transparent:true, opacity:0.25
              })
            );
            bubble.position.set((Math.random() - 0.5) * 25, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 15);
            bubble.userData.floatPhase = Math.random() * Math.PI * 2;
            bubble.userData.floatSpeed = 0.008 + Math.random() * 0.005;
            installationGroup.add(bubble);
          }
          break;
        }
        case 'luxury': {
          // é‡‘è‰²é’»çŸ³
          const diamond = new THREE.Mesh(
            new THREE.OctahedronGeometry(5, 0),
            new THREE.MeshStandardMaterial({ color: c.accent, metalness:1, roughness:0 })
          );
          diamond.scale.y = 1.5;
          diamond.userData.isInstallation = true;
          diamond.userData.rotSpeed = 0.005;
          installationGroup.add(diamond);
          // é‡‘çº¿
          for (let i = 0; i < 4; i++) {
            const ring = new THREE.Mesh(
              new THREE.TorusGeometry(8 + i * 2, 0.05, 8, 100),
              new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.4 })
            );
            ring.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
            ring.userData.isInstallation = true;
            ring.userData.rotSpeed = 0.003 * (i + 1);
            installationGroup.add(ring);
          }
          break;
        }
        case 'neumorphism':
        case 'clay': {
          // æŸ”å’Œå‡¹å‡¸çƒç»„
          for (let i = 0; i < 7; i++) {
            const softSphere = new THREE.Mesh(
              new THREE.SphereGeometry(2 + Math.random() * 2, 32, 32),
              new THREE.MeshStandardMaterial({
                color: i % 2 === 0 ? c.accent : c.accent2,
                metalness:0, roughness:0.8
              })
            );
            softSphere.position.set((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
            softSphere.userData.floatPhase = Math.random() * Math.PI * 2;
            softSphere.userData.floatSpeed = 0.008;
            softSphere.userData.isBounce = true;
            installationGroup.add(softSphere);
          }
          break;
        }
        case 'greek': {
          for (let i = 0; i < 6; i++) {
            const col = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 12, 16), new THREE.MeshStandardMaterial({ color:'#e8e0d0', roughness:0.5 }));
            col.position.set((i - 2.5) * 4, -9, -5);
            installationGroup.add(col);
            const cap = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.5, 1.5), new THREE.MeshStandardMaterial({ color:'#e8e0d0', roughness:0.5 }));
            cap.position.set((i - 2.5) * 4, -3, -5);
            installationGroup.add(cap);
          }
          const beam = new THREE.Mesh(new THREE.BoxGeometry(25, 1, 2), new THREE.MeshStandardMaterial({ color:'#e8e0d0', roughness:0.5 }));
          beam.position.set(0, -2.5, -5);
          installationGroup.add(beam);
          break;
        }
        case 'gradient': {
          // æ¸å˜æµä½“çƒï¼šå¤šä¸ªåŠé€æ˜çƒç¼“æ…¢èåˆæ¼‚ç§»
          for (let i = 0; i < 8; i++) {
            const blob = new THREE.Mesh(
              new THREE.SphereGeometry(2 + Math.random() * 3, 32, 32),
              new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? c.accent : c.accent2, transparent:true, opacity:0.3 })
            );
            blob.position.set((Math.random() - 0.5) * 15, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
            blob.userData.floatPhase = Math.random() * Math.PI * 2;
            blob.userData.floatSpeed = 0.008;
            blob.userData.orbitRadius = 3 + Math.random() * 5;
            blob.userData.orbitSpeed = 0.003 + Math.random() * 0.005;
            blob.userData.isOrbit = true;
            installationGroup.add(blob);
          }
          break;
        }
        case 'zen': {
          // æ¯å±±æ°´ï¼šçŸ³å¤´ + ç ‚çº¹åŒå¿ƒåœ†
          const stones = [[0, -12, 0, 2.5], [-6, -12.5, -3, 1.5], [5, -12.8, 2, 1]];
          stones.forEach(([x, y, z, r]) => {
            const stone = new THREE.Mesh(new THREE.SphereGeometry(r, 12, 12), new THREE.MeshStandardMaterial({ color:'#606060', roughness:0.95 }));
            stone.position.set(x, y, z); stone.scale.y = 0.6;
            installationGroup.add(stone);
            // åŒå¿ƒåœ†ç ‚çº¹
            for (let ri = 1; ri <= 4; ri++) {
              const ring = new THREE.Mesh(
                new THREE.TorusGeometry(r + ri * 1.2, 0.03, 8, 80),
                new THREE.MeshBasicMaterial({ color:'#a09080', transparent:true, opacity:0.4 })
              );
              ring.rotation.x = Math.PI / 2; ring.position.set(x, -14.8, z);
              installationGroup.add(ring);
            }
          });
          break;
        }
        case 'midnight': {
          // æ˜Ÿåº§è¿çº¿ + æœˆäº®
          const starPositions = [];
          for (let i = 0; i < 20; i++) {
            const star = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 8), new THREE.MeshBasicMaterial({ color:'#fff' }));
            const pos = new THREE.Vector3((Math.random() - 0.5) * 30, Math.random() * 15, (Math.random() - 0.5) * 20 - 10);
            star.position.copy(pos); starPositions.push(pos);
            installationGroup.add(star);
          }
          // è¿çº¿
          for (let i = 0; i < starPositions.length - 1; i++) {
            if (starPositions[i].distanceTo(starPositions[i + 1]) < 15) {
              const lineGeo = new THREE.BufferGeometry().setFromPoints([starPositions[i], starPositions[i + 1]]);
              installationGroup.add(new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color:'#4b0082', transparent:true, opacity:0.3 })));
            }
          }
          break;
        }
        case 'desert': {
          // é‡‘å­—å¡”ç¾¤
          for (let i = 0; i < 3; i++) {
            const pyramid = new THREE.Mesh(
              new THREE.ConeGeometry(4 + i * 2, 8 + i * 3, 4),
              new THREE.MeshStandardMaterial({ color: c.accent, metalness:0.2, roughness:0.8 })
            );
            pyramid.position.set((i - 1) * 10, -11 + (8 + i * 3) / 2, -5);
            pyramid.rotation.y = Math.PI / 4;
            installationGroup.add(pyramid);
          }
          break;
        }
        case 'github': {
          // è´¡çŒ®çƒ­åŠ›å›¾ 3D
          for (let w = 0; w < 20; w++) {
            for (let d = 0; d < 7; d++) {
              const intensity = Math.random();
              if (intensity < 0.3) continue;
              const cell = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, intensity * 5, 0.8),
                new THREE.MeshBasicMaterial({ color: new THREE.Color(c.accent).multiplyScalar(0.3 + intensity * 0.7), transparent:true, opacity:0.6 + intensity * 0.4 })
              );
              cell.position.set(w * 1 - 10, intensity * 2.5 - 10, d * 1 - 3);
              installationGroup.add(cell);
            }
          }
          break;
        }
        case 'discord': {
          // æ¶ˆæ¯æ°”æ³¡ç¾¤
          for (let i = 0; i < 12; i++) {
            const bubble = new THREE.Mesh(
              new THREE.BoxGeometry(4 + Math.random() * 4, 1.5, 0.3),
              new THREE.MeshBasicMaterial({ color: i % 3 === 0 ? c.accent : c.accent2, transparent:true, opacity:0.5 })
            );
            bubble.position.set((i % 2 === 0 ? -1 : 1) * (3 + Math.random() * 3), i * 2 - 12, Math.random() * 5);
            bubble.userData.floatPhase = i * 0.5; bubble.userData.floatSpeed = 0.005;
            installationGroup.add(bubble);
          }
          break;
        }
        case 'figma': {
          // Figmaå››è‰²æ—‹è½¬ç»„ä»¶
          const figmaColors = ['#f24e1e','#ff7262','#a259ff','#1abcfe','#0acf83'];
          figmaColors.forEach((fc, i) => {
            const shape = new THREE.Mesh(
              i < 2 ? new THREE.CircleGeometry(2, 32) : new THREE.BoxGeometry(3.5, 3.5, 0.3),
              new THREE.MeshBasicMaterial({ color:fc, side:THREE.DoubleSide })
            );
            const angle = (i / figmaColors.length) * Math.PI * 2;
            shape.position.set(Math.cos(angle) * 6, Math.sin(angle) * 6, 0);
            shape.userData.isInstallation = true; shape.userData.rotSpeed = 0.005;
            installationGroup.add(shape);
          });
          break;
        }
        case 'stripe':
        case 'linear': {
          // æ¸å˜å…‰æŸ
          for (let i = 0; i < 8; i++) {
            const ray = new THREE.Mesh(
              new THREE.PlaneGeometry(0.5, 30),
              new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? c.accent : c.accent2, transparent:true, opacity:0.2, side:THREE.DoubleSide })
            );
            ray.position.z = -10; ray.rotation.z = (i / 8) * Math.PI;
            ray.userData.isInstallation = true; ray.userData.rotSpeed = 0.002;
            installationGroup.add(ray);
          }
          // ä¸­å¿ƒçƒ
          const core = new THREE.Mesh(new THREE.SphereGeometry(3, 32, 32), new THREE.MeshBasicMaterial({ color: c.accent, transparent:true, opacity:0.6 }));
          core.userData.isInstallation = true; core.userData.rotSpeed = 0.01;
          installationGroup.add(core);
          break;
        }
        case 'fluent': {
          // äºšå…‹åŠ›å±‚å ç»ç’ƒæ¿
          for (let i = 0; i < 5; i++) {
            const panel = new THREE.Mesh(
              new THREE.PlaneGeometry(10, 7),
              new THREE.MeshPhysicalMaterial({ color: i % 2 === 0 ? c.accent : c.accent2, metalness:0.1, roughness:0.1, transparent:true, opacity:0.25, side:THREE.DoubleSide })
            );
            panel.position.set(i * 1.5 - 3, i * 0.5 - 1, i * 2 - 4);
            panel.rotation.y = -0.2;
            installationGroup.add(panel);
          }
          break;
        }
        case 'notion': {
          // æ¨¡å—åŒ–ç¬”è®°å—
          const blockSizes = [[6,2],[4,1.5],[5,2.5],[3,1],[7,1.5],[4,2]];
          blockSizes.forEach(([w, h], i) => {
            const block = new THREE.Mesh(
              new THREE.BoxGeometry(w, h, 0.2),
              new THREE.MeshBasicMaterial({ color: i === 0 ? '#ffffff' : '#404040', transparent:true, opacity: i === 0 ? 0.8 : 0.4 })
            );
            block.position.set((i % 2) * 5 - 2.5, i * 2.5 - 8, 0);
            installationGroup.add(block);
          });
          break;
        }
        case 'korean': {
          // éŸ©æœè‰²å½©é£˜å¸¦
          for (let i = 0; i < 6; i++) {
            const ribbon = new THREE.Mesh(
              new THREE.PlaneGeometry(12, 1, 20, 1),
              new THREE.MeshBasicMaterial({ color: ['#ffb6c1','#87ceeb','#fff5ee','#e6e6fa','#f0fff0','#ffefd5'][i], transparent:true, opacity:0.5, side:THREE.DoubleSide })
            );
            ribbon.position.set(0, i * 2 - 5, -2 + i * 0.5);
            ribbon.userData.wavePhase = i * 0.8; ribbon.userData.isWave = true;
            installationGroup.add(ribbon);
          }
          break;
        }
        case 'african': {
          // éƒ¨è½é¢å…·ç¾¤
          for (let i = 0; i < 5; i++) {
            const mask = new THREE.Group();
            const face = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1, 3, 6), new THREE.MeshStandardMaterial({ color: c.accent, roughness:0.9 }));
            mask.add(face);
            const eyeL = new THREE.Mesh(new THREE.CircleGeometry(0.3, 6), new THREE.MeshBasicMaterial({ color:'#000', side:THREE.DoubleSide }));
            eyeL.position.set(-0.5, 0.5, 1); mask.add(eyeL);
            const eyeR = eyeL.clone(); eyeR.position.x = 0.5; mask.add(eyeR);
            mask.position.set((i - 2) * 5, (i % 2) * 3 - 2, 0);
            mask.rotation.y = (Math.random() - 0.5) * 0.5;
            mask.userData.isInstallation = true; mask.userData.rotSpeed = 0.002;
            installationGroup.add(mask);
          }
          break;
        }
        case 'mediterranean': {
          // è“ç™½æ•™å ‚åœ†é¡¶
          const church = new THREE.Group();
          const base = new THREE.Mesh(new THREE.BoxGeometry(6, 6, 6), new THREE.MeshStandardMaterial({ color:'#ffffff', roughness:0.6 }));
          base.position.y = -9;
          church.add(base);
          const dome = new THREE.Mesh(new THREE.SphereGeometry(3.5, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshStandardMaterial({ color:'#1e90ff', roughness:0.3 }));
          dome.position.y = -6;
          church.add(dome);
          const cross = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2, 0.2), new THREE.MeshBasicMaterial({ color:'#ffd700' }));
          cross.position.y = -3;
          church.add(cross);
          installationGroup.add(church);
          // ç¬¬äºŒä¸ªå°æ•™å ‚
          const church2 = church.clone();
          church2.position.set(8, 1, -3); church2.scale.setScalar(0.7);
          installationGroup.add(church2);
          break;
        }
        case 'dieselpunk': {
          // ç²—çŠ·ç®¡é“å’Œé“†é’‰
          for (let i = 0; i < 6; i++) {
            const pipe = new THREE.Mesh(
              new THREE.CylinderGeometry(0.4, 0.4, 15 + Math.random() * 10, 8),
              new THREE.MeshStandardMaterial({ color:'#555', metalness:0.8, roughness:0.3 })
            );
            pipe.position.set((Math.random() - 0.5) * 15, -5, (Math.random() - 0.5) * 10);
            pipe.rotation.z = (Math.random() - 0.5) * 1;
            installationGroup.add(pipe);
          }
          // å¤§é½¿è½®
          const bigGear = new THREE.Mesh(new THREE.TorusGeometry(5, 1, 8, 12), new THREE.MeshStandardMaterial({ color:'#8b4513', metalness:0.7, roughness:0.3 }));
          bigGear.userData.isInstallation = true; bigGear.userData.rotSpeed = 0.005; bigGear.userData.rotAxis = 'z';
          installationGroup.add(bigGear);
          break;
        }
        case 'comic': {
          // POW! BANG! çˆ†ç‚¸å½¢çŠ¶
          for (let i = 0; i < 3; i++) {
            const burst = new THREE.Mesh(
              new THREE.CircleGeometry(4, i === 0 ? 12 : 8),
              new THREE.MeshBasicMaterial({ color: ['#ffff00','#ff0000','#ffffff'][i], transparent:true, opacity:0.8, side:THREE.DoubleSide })
            );
            burst.position.set((i - 1) * 8, (i - 1) * 2, 0);
            burst.scale.set(1 + i * 0.3, 1 + i * 0.2, 1);
            burst.userData.isInstallation = true; burst.userData.rotSpeed = 0.003 * (i + 1); burst.userData.rotAxis = 'z';
            installationGroup.add(burst);
          }
          break;
        }
        case 'sketch': {
          // æ‰‹ç»˜çº¿æ¡å‡ ä½•ä½“
          for (let i = 0; i < 8; i++) {
            const wireGeo = [new THREE.BoxGeometry(4,4,4), new THREE.SphereGeometry(3,6,6), new THREE.ConeGeometry(3,5,5)][i % 3];
            const wireObj = new THREE.Mesh(wireGeo, new THREE.MeshBasicMaterial({ color:'#808080', wireframe:true, transparent:true, opacity:0.6 }));
            wireObj.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 12, (Math.random() - 0.5) * 10);
            wireObj.userData.isInstallation = true; wireObj.userData.rotSpeed = (Math.random() - 0.5) * 0.005;
            installationGroup.add(wireObj);
          }
          break;
        }
        case 'abstract': {
          // åº·å®šæ–¯åŸºé£æ ¼æ„æˆ
          const absShapes = [
            { geo: new THREE.CircleGeometry(5, 32), color:'#ff6347', pos:[0,2,0] },
            { geo: new THREE.BoxGeometry(8, 0.3, 0.3), color:'#4169e1', pos:[0,-3,0] },
            { geo: new THREE.ConeGeometry(3, 6, 3), color:'#ffd700', pos:[-6,0,0] },
            { geo: new THREE.TorusGeometry(3, 0.2, 8, 40), color:'#ff6347', pos:[6,-1,0] },
            { geo: new THREE.BoxGeometry(4, 4, 0.2), color:'#4169e1', pos:[3,5,0] },
          ];
          absShapes.forEach((s, i) => {
            const mesh = new THREE.Mesh(s.geo, new THREE.MeshBasicMaterial({ color:s.color, transparent:true, opacity:0.7, side:THREE.DoubleSide }));
            mesh.position.set(...s.pos);
            mesh.rotation.z = i * 0.3;
            mesh.userData.isInstallation = true; mesh.userData.rotSpeed = 0.002 * (i % 2 === 0 ? 1 : -1);
            installationGroup.add(mesh);
          });
          break;
        }
        case 'brutal':
        case 'poster': {
          // åšé‡3Dæ–‡å­—å—
          for (let i = 0; i < 5; i++) {
            const block = new THREE.Mesh(
              new THREE.BoxGeometry(3 + Math.random() * 5, 2 + Math.random() * 3, 2),
              new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? c.accent : c.accent2, transparent:true, opacity:0.8 })
            );
            block.position.set((Math.random() - 0.5) * 15, i * 3 - 8, -2 + Math.random() * 4);
            // ç¡¬é˜´å½±
            const shadow = block.clone();
            shadow.material = new THREE.MeshBasicMaterial({ color:'#000', transparent:true, opacity:0.3 });
            shadow.position.x += 0.5; shadow.position.y -= 0.5;
            installationGroup.add(shadow);
            installationGroup.add(block);
          }
          break;
        }
        case 'energetic':
        case 'sports': {
          // èƒ½é‡çˆ†å‘çƒ
          const energyCore = new THREE.Mesh(new THREE.SphereGeometry(3, 32, 32), new THREE.MeshBasicMaterial({ color: c.accent }));
          energyCore.userData.isInstallation = true; energyCore.userData.rotSpeed = 0.02;
          installationGroup.add(energyCore);
          // å°„çº¿
          for (let i = 0; i < 16; i++) {
            const ray = new THREE.Mesh(
              new THREE.CylinderGeometry(0.05, 0.3, 12, 4),
              new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.5 })
            );
            const angle = (i / 16) * Math.PI * 2;
            ray.position.set(Math.cos(angle) * 8, Math.sin(angle) * 8, 0);
            ray.rotation.z = angle - Math.PI / 2;
            ray.userData.isInstallation = true; ray.userData.rotSpeed = 0.003;
            installationGroup.add(ray);
          }
          break;
        }
        case 'mysterious': {
          // ç¥ç§˜ç¬¦æ–‡é­”æ³•é˜µ
          for (let ring = 0; ring < 3; ring++) {
            const runeRing = new THREE.Mesh(
              new THREE.TorusGeometry(5 + ring * 3, 0.1, 8, 60),
              new THREE.MeshBasicMaterial({ color: c.accent, transparent:true, opacity:0.5 })
            );
            runeRing.rotation.x = Math.PI / 2;
            runeRing.userData.isInstallation = true;
            runeRing.userData.rotSpeed = 0.005 * (ring % 2 === 0 ? 1 : -1);
            installationGroup.add(runeRing);
            // ç¬¦æ–‡çƒ
            for (let j = 0; j < 6; j++) {
              const rune = new THREE.Mesh(new THREE.OctahedronGeometry(0.4), new THREE.MeshBasicMaterial({ color: c.accent2 }));
              const a = (j / 6) * Math.PI * 2;
              rune.position.set(Math.cos(a) * (5 + ring * 3), 0, Math.sin(a) * (5 + ring * 3));
              installationGroup.add(rune);
            }
          }
          break;
        }
        case 'cheerful':
        case 'kids': {
          // å½©è‰²æ°”çƒç¾¤
          const balloonColors = ['#ff69b4','#ffd700','#00ced1','#ff6347','#98fb98','#dda0dd'];
          for (let i = 0; i < 10; i++) {
            const balloon = new THREE.Mesh(new THREE.SphereGeometry(1 + Math.random(), 16, 16), new THREE.MeshBasicMaterial({ color: balloonColors[i % balloonColors.length] }));
            balloon.position.set((Math.random() - 0.5) * 20, Math.random() * 10, (Math.random() - 0.5) * 15);
            balloon.scale.y = 1.3;
            balloon.userData.floatPhase = Math.random() * Math.PI * 2; balloon.userData.floatSpeed = 0.008;
            // ç»³å­
            const string = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 4, 4), new THREE.MeshBasicMaterial({ color:'#888' }));
            string.position.y = -2.5;
            balloon.add(string);
            installationGroup.add(balloon);
          }
          break;
        }
        case 'swiss': {
          // ç²¾ç¡®çº¢è‰²åå­—+ç½‘æ ¼
          const cross1 = new THREE.Mesh(new THREE.BoxGeometry(2, 8, 1), new THREE.MeshBasicMaterial({ color:'#ff0000' }));
          const cross2 = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 1), new THREE.MeshBasicMaterial({ color:'#ff0000' }));
          installationGroup.add(cross1, cross2);
          // ç½‘æ ¼å‚è€ƒçº¿
          for (let i = -5; i <= 5; i++) {
            const hLine = new THREE.Mesh(new THREE.BoxGeometry(30, 0.02, 0.02), new THREE.MeshBasicMaterial({ color:'#333', transparent:true, opacity:0.3 }));
            hLine.position.y = i * 2;
            const vLine = new THREE.Mesh(new THREE.BoxGeometry(0.02, 30, 0.02), new THREE.MeshBasicMaterial({ color:'#333', transparent:true, opacity:0.3 }));
            vLine.position.x = i * 2;
            installationGroup.add(hLine, vLine);
          }
          break;
        }
        case 'nordic': {
          // ç®€æ´æœ¨è´¨å®¶å…·è½®å»“
          // æ¤…å­
          const seat = new THREE.Mesh(new THREE.BoxGeometry(3, 0.3, 3), new THREE.MeshStandardMaterial({ color:'#deb887', roughness:0.8 }));
          seat.position.set(-4, -10, 0);
          installationGroup.add(seat);
          for (let leg = 0; leg < 4; leg++) {
            const l = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 4, 8), new THREE.MeshStandardMaterial({ color:'#deb887', roughness:0.8 }));
            l.position.set(-4 + (leg % 2 === 0 ? -1 : 1), -12, (leg < 2 ? -1 : 1));
            installationGroup.add(l);
          }
          // ç¯
          const lamp = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 16), new THREE.MeshBasicMaterial({ color: c.accent, transparent:true, opacity:0.5 }));
          lamp.position.set(5, 2, 0);
          const lampLine = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 8, 4), new THREE.MeshBasicMaterial({ color:'#333' }));
          lampLine.position.set(5, 6, 0);
          installationGroup.add(lamp, lampLine);
          break;
        }
        case 'muji':
        case 'handmade': {
          // é™¶ç“·å™¨çš¿
          for (let i = 0; i < 4; i++) {
            const pot = new THREE.Mesh(
              new THREE.LatheGeometry([
                new THREE.Vector2(0,0), new THREE.Vector2(1 + i * 0.3, 0.5), new THREE.Vector2(1.2 + i * 0.2, 2), new THREE.Vector2(0.8 + i * 0.1, 3), new THREE.Vector2(0.9 + i * 0.2, 3.2),
              ], 16),
              new THREE.MeshStandardMaterial({ color: c.accent, roughness:0.9 })
            );
            pot.position.set((i - 1.5) * 5, -12, 0);
            installationGroup.add(pot);
          }
          break;
        }
        case 'mono': {
          // é»‘ç™½æ£‹ç›˜åµŒå¥—
          for (let i = 0; i < 5; i++) {
            const box = new THREE.Mesh(
              new THREE.BoxGeometry(10 - i * 2, 10 - i * 2, 10 - i * 2),
              new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? '#ffffff' : '#000000', wireframe: i % 2 === 1, transparent:true, opacity: i % 2 === 0 ? 0.3 : 0.6 })
            );
            box.userData.isInstallation = true; box.userData.rotSpeed = 0.003 * (i % 2 === 0 ? 1 : -1);
            installationGroup.add(box);
          }
          break;
        }
        case 'flat': {
          // æ‰å¹³å›¾æ ‡ç½‘æ ¼
          const flatColors = ['#3498db','#e74c3c','#2ecc71','#f39c12','#9b59b6','#1abc9c'];
          for (let i = 0; i < 9; i++) {
            const icon = new THREE.Mesh(
              i % 3 === 0 ? new THREE.CircleGeometry(2, 32) : new THREE.BoxGeometry(3, 3, 0.1),
              new THREE.MeshBasicMaterial({ color: flatColors[i % flatColors.length], side:THREE.DoubleSide })
            );
            icon.position.set(((i % 3) - 1) * 5, (Math.floor(i / 3) - 1) * 5, 0);
            installationGroup.add(icon);
          }
          break;
        }
        case 'nature': {
          // ç”Ÿé•¿çš„å¤§æ ‘
          const treeT = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.8, 10, 8), new THREE.MeshStandardMaterial({ color:'#4a3728', roughness:0.9 }));
          treeT.position.y = -10;
          installationGroup.add(treeT);
          // åˆ†æ”¯
          for (let i = 0; i < 20; i++) {
            const leaf = new THREE.Mesh(new THREE.SphereGeometry(1.5 + Math.random() * 2, 8, 8), new THREE.MeshBasicMaterial({ color: Math.random() > 0.3 ? c.accent : c.accent2, transparent:true, opacity:0.5 }));
            leaf.position.set((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 8 + 2, (Math.random() - 0.5) * 10);
            installationGroup.add(leaf);
          }
          break;
        }
        case 'coral': {
          // çŠç‘šç¤
          for (let i = 0; i < 15; i++) {
            const coral = new THREE.Mesh(
              Math.random() > 0.5 ? new THREE.ConeGeometry(0.5 + Math.random(), 3 + Math.random() * 4, 6) : new THREE.SphereGeometry(1 + Math.random(), 8, 8),
              new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? c.accent : c.accent2, transparent:true, opacity:0.6 })
            );
            coral.position.set((Math.random() - 0.5) * 20, -13 + Math.random() * 3, (Math.random() - 0.5) * 15);
            installationGroup.add(coral);
          }
          break;
        }
        case 'wood':
        case 'leather': {
          // æœ¨é›•/çš®é©å·¥è‰ºå“æ—‹è½¬å±•ç¤º
          const artifact = new THREE.Mesh(new THREE.DodecahedronGeometry(5, 0), new THREE.MeshStandardMaterial({ color: c.accent, roughness:0.8, metalness:0 }));
          artifact.userData.isInstallation = true; artifact.userData.rotSpeed = 0.003;
          installationGroup.add(artifact);
          const stand = new THREE.Mesh(new THREE.CylinderGeometry(2, 3, 2, 8), new THREE.MeshStandardMaterial({ color: c.accent2, roughness:0.9 }));
          stand.position.y = -10;
          installationGroup.add(stand);
          break;
        }
        case 'paper': {
          // åƒçº¸é¹¤ç¾¤ï¼ˆç®€åŒ–ä¸ºä¸‰è§’é”¥ï¼‰
          for (let i = 0; i < 20; i++) {
            const crane = new THREE.Mesh(
              new THREE.ConeGeometry(0.5, 1.5, 3),
              new THREE.MeshBasicMaterial({ color: ['#f5deb3','#ffefd5','#ffe4c4','#ffdab9'][i % 4], transparent:true, opacity:0.7 })
            );
            crane.position.set((Math.random() - 0.5) * 25, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 20);
            crane.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            crane.userData.floatPhase = Math.random() * Math.PI * 2; crane.userData.floatSpeed = 0.005;
            installationGroup.add(crane);
          }
          break;
        }
        case 'medical': {
          // DNAåŒèºæ—‹
          for (let i = 0; i < 40; i++) {
            const t = i * 0.2;
            const y = i * 0.7 - 14;
            [[Math.cos(t) * 4, y, Math.sin(t) * 4], [Math.cos(t + Math.PI) * 4, y, Math.sin(t + Math.PI) * 4]].forEach((p, j) => {
              const node = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshBasicMaterial({ color: j === 0 ? c.accent : '#fff' }));
              node.position.set(...p);
              installationGroup.add(node);
            });
            if (i % 3 === 0) {
              const bridge = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 8, 4), new THREE.MeshBasicMaterial({ color:'#aaa', transparent:true, opacity:0.3 }));
              bridge.position.set(0, y, 0); bridge.rotation.z = Math.PI / 2; bridge.rotation.y = t;
              installationGroup.add(bridge);
            }
          }
          break;
        }
        case 'education': {
          // ç¿»å¼€çš„ä¹¦æœ¬
          const bookL = new THREE.Mesh(new THREE.BoxGeometry(5, 7, 0.3), new THREE.MeshStandardMaterial({ color:'#fff', roughness:0.8 }));
          bookL.position.set(-2.6, -5, 0); bookL.rotation.y = 0.2;
          const bookR = bookL.clone(); bookR.position.x = 2.6; bookR.rotation.y = -0.2;
          const spine = new THREE.Mesh(new THREE.BoxGeometry(0.5, 7, 0.5), new THREE.MeshStandardMaterial({ color: c.accent, roughness:0.7 }));
          spine.position.y = -5;
          installationGroup.add(bookL, bookR, spine);
          // é£å‡ºçš„å­—æ¯
          for (let i = 0; i < 15; i++) {
            const letter = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.1), new THREE.MeshBasicMaterial({ color: c.accent }));
            letter.position.set((Math.random() - 0.5) * 15, Math.random() * 10, (Math.random() - 0.5) * 10);
            letter.userData.floatPhase = Math.random() * Math.PI * 2; letter.userData.floatSpeed = 0.008;
            installationGroup.add(letter);
          }
          break;
        }
        case 'food': {
          // ç¾é£Ÿæ—‹è½¬å±•å°
          const plate = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 0.3, 32), new THREE.MeshStandardMaterial({ color:'#f0f0f0', roughness:0.3 }));
          plate.position.y = -8;
          plate.userData.isInstallation = true; plate.userData.rotSpeed = 0.005;
          installationGroup.add(plate);
          // é£Ÿç‰©ï¼ˆå½©è‰²çƒä½“ï¼‰
          const foodColors = ['#ff8c00','#ff4500','#32cd32','#ffd700','#ff69b4'];
          for (let i = 0; i < 5; i++) {
            const food = new THREE.Mesh(new THREE.SphereGeometry(1 + Math.random(), 16, 16), new THREE.MeshBasicMaterial({ color: foodColors[i] }));
            const a = (i / 5) * Math.PI * 2;
            food.position.set(Math.cos(a) * 3, -7, Math.sin(a) * 3);
            food.userData.isInstallation = true; food.userData.rotSpeed = 0.005;
            installationGroup.add(food);
          }
          break;
        }
        case 'travel': {
          const globe = new THREE.Mesh(new THREE.SphereGeometry(6, 32, 32), new THREE.MeshBasicMaterial({ color: c.accent, wireframe:true, transparent:true, opacity:0.4 }));
          globe.userData.isInstallation = true; globe.userData.rotSpeed = 0.003;
          installationGroup.add(globe);
          for (let i = 0; i < 3; i++) {
            const path = new THREE.Mesh(new THREE.TorusGeometry(7 + i, 0.05, 8, 100), new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.5 }));
            path.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
            path.userData.isInstallation = true; path.userData.rotSpeed = 0.005 + i * 0.002;
            installationGroup.add(path);
          }
          break;
        }
        case 'wedding': {
          // å©šæˆ’ + èŠ±ç“£å…‰
          const ring1 = new THREE.Mesh(new THREE.TorusGeometry(4, 0.5, 16, 100), new THREE.MeshStandardMaterial({ color:'#ffd700', metalness:1, roughness:0 }));
          ring1.position.set(-2, 0, 0); ring1.rotation.y = 0.3;
          const ring2 = ring1.clone(); ring2.position.x = 2; ring2.rotation.y = -0.3;
          ring1.userData.isInstallation = true; ring1.userData.rotSpeed = 0.003;
          ring2.userData.isInstallation = true; ring2.userData.rotSpeed = 0.003;
          installationGroup.add(ring1, ring2);
          // é’»çŸ³
          const diamond = new THREE.Mesh(new THREE.OctahedronGeometry(1, 0), new THREE.MeshStandardMaterial({ color:'#fff', metalness:0.8, roughness:0 }));
          diamond.position.set(0, 5, 0); diamond.scale.y = 1.3;
          diamond.userData.isInstallation = true; diamond.userData.rotSpeed = 0.01;
          installationGroup.add(diamond);
          break;
        }
        case 'cottagecore': {
          // å°æœ¨å±‹
          const cabin = new THREE.Group();
          const walls = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 5), new THREE.MeshStandardMaterial({ color:'#deb887', roughness:0.9 }));
          walls.position.y = -10;
          cabin.add(walls);
          const roof = new THREE.Mesh(new THREE.ConeGeometry(5, 3, 4), new THREE.MeshStandardMaterial({ color:'#8b4513', roughness:0.8 }));
          roof.position.y = -7; roof.rotation.y = Math.PI / 4;
          cabin.add(roof);
          // å°èŠ±
          for (let i = 0; i < 8; i++) {
            const flower = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshBasicMaterial({ color: ['#ff69b4','#ffd700','#ff6347','#dda0dd'][i % 4] }));
            flower.position.set((Math.random() - 0.5) * 12, -12, 4 + Math.random() * 3);
            installationGroup.add(flower);
          }
          installationGroup.add(cabin);
          break;
        }
        case 'lightacademia': {
          // é˜³å…‰ä¹¦æ¡Œ + å’–å•¡æ¯
          const desk = new THREE.Mesh(new THREE.BoxGeometry(10, 0.3, 5), new THREE.MeshStandardMaterial({ color:'#deb887', roughness:0.7 }));
          desk.position.y = -8;
          installationGroup.add(desk);
          // ä¹¦
          for (let i = 0; i < 4; i++) {
            const book = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 2), new THREE.MeshBasicMaterial({ color: ['#8b4513','#006400','#00008b','#4b0082'][i] }));
            book.position.set(-3 + i * 2, -7.6, 0);
            installationGroup.add(book);
          }
          // å’–å•¡æ¯
          const cup = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.4, 1, 16), new THREE.MeshStandardMaterial({ color:'#f5f5f5', roughness:0.3 }));
          cup.position.set(4, -7.3, 1);
          installationGroup.add(cup);
          break;
        }
        case 'sunny': {
          // ç¬‘è„¸å¤ªé˜³
          const sunFace = new THREE.Mesh(new THREE.CircleGeometry(5, 32), new THREE.MeshBasicMaterial({ color: c.accent, side:THREE.DoubleSide }));
          installationGroup.add(sunFace);
          // å…‰çº¿
          for (let i = 0; i < 12; i++) {
            const ray = new THREE.Mesh(new THREE.BoxGeometry(0.5, 3, 0.1), new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.6 }));
            const a = (i / 12) * Math.PI * 2;
            ray.position.set(Math.cos(a) * 7, Math.sin(a) * 7, 0);
            ray.rotation.z = a;
            installationGroup.add(ray);
          }
          installationGroup.userData.isInstallation = true; installationGroup.userData.rotSpeed = 0.002;
          break;
        }
        case 'rainy':
        case 'melancholy': {
          // é›¨ä¼
          const umbrella = new THREE.Group();
          const canopy = new THREE.Mesh(new THREE.SphereGeometry(5, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshBasicMaterial({ color: c.accent, transparent:true, opacity:0.6 }));
          canopy.rotation.x = Math.PI;
          umbrella.add(canopy);
          const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 8, 8), new THREE.MeshBasicMaterial({ color:'#555' }));
          handle.position.y = 4;
          umbrella.add(handle);
          umbrella.position.y = 2;
          umbrella.userData.isInstallation = true; umbrella.userData.rotSpeed = 0.003;
          installationGroup.add(umbrella);
          break;
        }
        case 'foggy': {
          // è¿·é›¾ä¸­çš„è·¯ç¯å‰ªå½±
          for (let i = 0; i < 4; i++) {
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 12, 8), new THREE.MeshBasicMaterial({ color:'#333', transparent:true, opacity:0.4 }));
            pole.position.set((i - 1.5) * 8, -9, -5);
            installationGroup.add(pole);
            const lampHead = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({ color:'#fffacd', transparent:true, opacity:0.4 }));
            lampHead.position.set((i - 1.5) * 8, -3, -5);
            installationGroup.add(lampHead);
          }
          break;
        }
        case 'dawn':
        case 'dusk': {
          // é£é¸Ÿå‰ªå½±
          for (let i = 0; i < 8; i++) {
            const bird = new THREE.Group();
            const wingL = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.3), new THREE.MeshBasicMaterial({ color:'#222', side:THREE.DoubleSide }));
            wingL.position.x = -0.8; wingL.rotation.z = 0.3;
            const wingR = wingL.clone(); wingR.position.x = 0.8; wingR.rotation.z = -0.3;
            bird.add(wingL, wingR);
            bird.position.set((Math.random() - 0.5) * 30, 5 + Math.random() * 10, -20 - Math.random() * 10);
            bird.scale.setScalar(0.5 + Math.random());
            bird.userData.floatPhase = Math.random() * Math.PI * 2; bird.userData.floatSpeed = 0.005;
            installationGroup.add(bird);
          }
          break;
        }
        case 'summer': {
          // æ¤°æ ‘ + æµ·æµª
          const palmTrunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 10, 8), new THREE.MeshStandardMaterial({ color:'#8b6914', roughness:0.9 }));
          palmTrunk.position.set(-5, -10, 0); palmTrunk.rotation.z = 0.15;
          installationGroup.add(palmTrunk);
          // æ£•æ¦ˆå¶
          for (let i = 0; i < 6; i++) {
            const frond = new THREE.Mesh(new THREE.PlaneGeometry(5, 1), new THREE.MeshBasicMaterial({ color:'#228b22', transparent:true, opacity:0.7, side:THREE.DoubleSide }));
            frond.position.set(-5, -4, 0);
            frond.rotation.z = (i / 6) * Math.PI * 2;
            frond.rotation.x = -0.5;
            installationGroup.add(frond);
          }
          break;
        }
        default: {
          // é»˜è®¤ï¼šæ—‹è½¬å¤šé¢ä½“ + å…‰ç¯
          const defGeo = new THREE.IcosahedronGeometry(6, 1);
          const defMat = new THREE.MeshStandardMaterial({
            color: c.accent, metalness:0.5, roughness:0.3, wireframe:true
          });
          const defMesh = new THREE.Mesh(defGeo, defMat);
          defMesh.userData.isInstallation = true;
          defMesh.userData.rotSpeed = 0.005;
          installationGroup.add(defMesh);
          for (let i = 0; i < 3; i++) {
            const ring = new THREE.Mesh(
              new THREE.TorusGeometry(8 + i * 2, 0.1, 16, 100),
              new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? c.accent : c.accent2, transparent:true, opacity:0.4 })
            );
            ring.rotation.x = Math.PI / 2 + i * 0.2;
            ring.userData.isInstallation = true;
            ring.userData.rotSpeed = 0.008 * (i + 1);
            installationGroup.add(ring);
          }
        }
      }

      // ====== æŠŠè£…ç½®ä¸­ç¬¬ä¸€ä¸ªæ ¸å¿ƒç‰©ä½“çš„æè´¨æ›¿æ¢ä¸º shader ======
      try {
        const shaderMat = getStyleShaderMaterial(style.id, c.accent, c.accent2);
        if (shaderMat && installationGroup.children.length > 0) {
          // æ‰¾åˆ°æœ€é€‚åˆæ›¿æ¢çš„æ ¸å¿ƒç‰©ä½“ï¼ˆç¬¬ä¸€ä¸ªæœ‰ isInstallation æ ‡è®°çš„ Meshï¼‰
          let target = null;
          for (const child of installationGroup.children) {
            if (child.isMesh && child.userData.isInstallation) {
              target = child; break;
            }
            // Group çš„æƒ…å†µï¼šæ‰¾å…¶ä¸­ç¬¬ä¸€ä¸ª Mesh
            if (child.isGroup && child.userData.isInstallation) {
              child.traverse(sub => { if (!target && sub.isMesh) target = sub; });
              if (target) break;
            }
          }
          // å¦‚æœæ²¡æ‰¾åˆ°å¸¦æ ‡è®°çš„ï¼Œå°±æ‰¾ç¬¬ä¸€ä¸ªè¶³å¤Ÿå¤§çš„ Mesh
          if (!target) {
            for (const child of installationGroup.children) {
              if (child.isMesh && child.geometry) {
                child.geometry.computeBoundingSphere();
                if (child.geometry.boundingSphere && child.geometry.boundingSphere.radius > 2) {
                  target = child; break;
                }
              }
            }
          }
          if (target) {
            // ä¿å­˜æ—§æè´¨ä»¥ä¾¿ dispose
            if (target.material && target.material.dispose) target.material.dispose();
            target.material = shaderMat;
            target.userData.isShaderCore = true;
          }
        }
      } catch(e) { /* shader åŠ è½½å¤±è´¥æ—¶é™é»˜ */ }
    }

    // ==================== ç²’å­ç³»ç»Ÿ ====================
    function createParticles(style) {
      while (particleGroup.children.length > 0) {
        const child = particleGroup.children[0];
        particleGroup.remove(child);
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      }

      const c = style.colors;
      const accent = new THREE.Color(c.accent);
      const accent2 = new THREE.Color(c.accent2);

      // åŸºç¡€ç²’å­åœº
      const baseCount = 800;
      const baseGeo = new THREE.BufferGeometry();
      const basePos = new Float32Array(baseCount * 3);
      const baseCol = new Float32Array(baseCount * 3);

      for (let i = 0; i < baseCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        const r = 30 + Math.random() * 40;
        basePos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        basePos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta) - 5;
        basePos[i * 3 + 2] = r * Math.cos(phi);

        const mix = Math.random();
        const color = accent.clone().lerp(accent2, mix);
        baseCol[i * 3] = color.r;
        baseCol[i * 3 + 1] = color.g;
        baseCol[i * 3 + 2] = color.b;
      }

      baseGeo.setAttribute('position', new THREE.BufferAttribute(basePos, 3));
      baseGeo.setAttribute('color', new THREE.BufferAttribute(baseCol, 3));

      const basePoints = new THREE.Points(baseGeo, new THREE.PointsMaterial({
        size: 0.25,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      }));
      basePoints.userData.isBaseParticle = true;
      particleGroup.add(basePoints);

      // é£æ ¼ç‰¹æ®Šç²’å­
      switch (style.id) {
        case 'japanese':
          // æ¨±èŠ±èŠ±ç“£
          for (let i = 0; i < 100; i++) {
            const petal = new THREE.Mesh(
              new THREE.CircleGeometry(0.3 + Math.random() * 0.3, 5),
              new THREE.MeshBasicMaterial({
                color: Math.random() > 0.3 ? c.accent : c.accent2,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide,
              })
            );
            petal.position.set(
              (Math.random() - 0.5) * 40,
              Math.random() * 30,
              (Math.random() - 0.5) * 40
            );
            petal.rotation.set(
              Math.random() * Math.PI,
              Math.random() * Math.PI,
              Math.random() * Math.PI
            );
            petal.userData.fallSpeed = 0.02 + Math.random() * 0.05;
            petal.userData.swaySpeed = 0.01 + Math.random() * 0.02;
            petal.userData.swayPhase = Math.random() * Math.PI * 2;
            petal.userData.isPetal = true;
            particleGroup.add(petal);
          }
          break;

        case 'winter':
          // é›ªèŠ±
          for (let i = 0; i < 150; i++) {
            const snow = new THREE.Mesh(
              new THREE.CircleGeometry(0.1 + Math.random() * 0.2, 6),
              new THREE.MeshBasicMaterial({
                color: '#ffffff',
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide,
              })
            );
            snow.position.set(
              (Math.random() - 0.5) * 50,
              Math.random() * 40 - 10,
              (Math.random() - 0.5) * 50
            );
            snow.userData.fallSpeed = 0.03 + Math.random() * 0.05;
            snow.userData.swaySpeed = 0.005 + Math.random() * 0.01;
            snow.userData.swayPhase = Math.random() * Math.PI * 2;
            snow.userData.isSnow = true;
            particleGroup.add(snow);
          }
          break;

        case 'matrix':
          // ä»£ç é›¨
          for (let i = 0; i < 100; i++) {
            const codeRain = new THREE.Mesh(
              new THREE.PlaneGeometry(0.3, 3 + Math.random() * 5),
              new THREE.MeshBasicMaterial({
                color: c.accent,
                transparent: true,
                opacity: 0.4 + Math.random() * 0.4,
                side: THREE.DoubleSide,
              })
            );
            codeRain.position.set(
              (Math.random() - 0.5) * 60,
              Math.random() * 40 - 10,
              (Math.random() - 0.5) * 40
            );
            codeRain.userData.fallSpeed = 0.1 + Math.random() * 0.2;
            codeRain.userData.isCodeRain = true;
            particleGroup.add(codeRain);
          }
          break;

        case 'romantic':
          // çˆ±å¿ƒ
          for (let i = 0; i < 30; i++) {
            const heartShape = new THREE.Shape();
            const x = 0, y = 0;
            heartShape.moveTo(x, y + 0.5);
            heartShape.bezierCurveTo(x + 0.5, y + 0.5, x + 0.4, y, x, y);
            heartShape.bezierCurveTo(x - 0.4, y, x - 0.5, y + 0.5, x, y + 0.5);

            const heart = new THREE.Mesh(
              new THREE.ShapeGeometry(heartShape),
              new THREE.MeshBasicMaterial({
                color: c.accent,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide,
              })
            );
            heart.scale.set(0.5 + Math.random() * 0.5, 0.5 + Math.random() * 0.5, 1);
            heart.position.set(
              (Math.random() - 0.5) * 30,
              Math.random() * 25 - 5,
              (Math.random() - 0.5) * 30
            );
            heart.rotation.z = Math.PI;
            heart.userData.floatSpeed = 0.01 + Math.random() * 0.02;
            heart.userData.floatPhase = Math.random() * Math.PI * 2;
            heart.userData.isHeart = true;
            particleGroup.add(heart);
          }
          break;

        case 'forest':
          // è¤ç«è™«
          for (let i = 0; i < 60; i++) {
            const firefly = new THREE.Mesh(
              new THREE.SphereGeometry(0.1, 8, 8),
              new THREE.MeshBasicMaterial({ color: c.accent2 })
            );
            firefly.position.set(
              (Math.random() - 0.5) * 40,
              Math.random() * 20 - 10,
              (Math.random() - 0.5) * 40
            );
            firefly.userData.floatSpeed = 0.005 + Math.random() * 0.01;
            firefly.userData.floatPhase = Math.random() * Math.PI * 2;
            firefly.userData.blinkPhase = Math.random() * Math.PI * 2;
            firefly.userData.isFirefly = true;
            particleGroup.add(firefly);
          }
          break;

        case 'autumn':
          // è½å¶
          for (let i = 0; i < 80; i++) {
            const leaf = new THREE.Mesh(
              new THREE.CircleGeometry(0.3 + Math.random() * 0.4, 5),
              new THREE.MeshBasicMaterial({
                color: ['#ff8c00','#ff4500','#8b4513','#ffd700','#b22222'][Math.floor(Math.random() * 5)],
                transparent:true, opacity:0.8, side:THREE.DoubleSide
              })
            );
            leaf.position.set((Math.random() - 0.5) * 40, Math.random() * 30, (Math.random() - 0.5) * 40);
            leaf.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            leaf.userData.fallSpeed = 0.02 + Math.random() * 0.04;
            leaf.userData.swaySpeed = 0.015 + Math.random() * 0.02;
            leaf.userData.swayPhase = Math.random() * Math.PI * 2;
            leaf.userData.isPetal = true;
            particleGroup.add(leaf);
          }
          break;

        case 'spring':
          // èŠ±ç“£å’Œè´è¶
          for (let i = 0; i < 60; i++) {
            const petal = new THREE.Mesh(
              new THREE.CircleGeometry(0.2 + Math.random() * 0.3, 5),
              new THREE.MeshBasicMaterial({
                color: ['#ffb7c5','#98fb98','#fffacd','#dda0dd'][Math.floor(Math.random() * 4)],
                transparent:true, opacity:0.7, side:THREE.DoubleSide
              })
            );
            petal.position.set((Math.random() - 0.5) * 40, Math.random() * 25, (Math.random() - 0.5) * 40);
            petal.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            petal.userData.fallSpeed = 0.015 + Math.random() * 0.03;
            petal.userData.swaySpeed = 0.02 + Math.random() * 0.02;
            petal.userData.swayPhase = Math.random() * Math.PI * 2;
            petal.userData.isPetal = true;
            particleGroup.add(petal);
          }
          break;

        case 'chinese':
          // é‡‘è‰²äº‘çº¹ç²’å­
          for (let i = 0; i < 40; i++) {
            const cloudlet = new THREE.Mesh(
              new THREE.SphereGeometry(0.3, 8, 8),
              new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.5 })
            );
            cloudlet.position.set((Math.random() - 0.5) * 30, Math.random() * 20, (Math.random() - 0.5) * 30);
            cloudlet.scale.set(1 + Math.random(), 0.5, 1 + Math.random());
            cloudlet.userData.floatSpeed = 0.003 + Math.random() * 0.005;
            cloudlet.userData.floatPhase = Math.random() * Math.PI * 2;
            cloudlet.userData.isHeart = true;
            particleGroup.add(cloudlet);
          }
          break;

        case 'gothic':
          // è™è å‰ªå½±
          for (let i = 0; i < 15; i++) {
            const bat = new THREE.Mesh(
              new THREE.ConeGeometry(0.4, 0.2, 3),
              new THREE.MeshBasicMaterial({ color:'#1a0008', transparent:true, opacity:0.8 })
            );
            bat.position.set((Math.random() - 0.5) * 40, Math.random() * 15 + 5, (Math.random() - 0.5) * 30);
            bat.rotation.x = Math.PI;
            bat.userData.floatSpeed = 0.02 + Math.random() * 0.03;
            bat.userData.floatPhase = Math.random() * Math.PI * 2;
            bat.userData.swaySpeed = 0.03;
            bat.userData.swayPhase = Math.random() * Math.PI * 2;
            bat.userData.isPetal = true;
            particleGroup.add(bat);
          }
          break;

        case 'ocean':
        case 'coral':
        case 'mediterranean':
          // æ°”æ³¡
          for (let i = 0; i < 80; i++) {
            const bubble = new THREE.Mesh(
              new THREE.SphereGeometry(0.1 + Math.random() * 0.3, 8, 8),
              new THREE.MeshBasicMaterial({ color: c.accent2, transparent:true, opacity:0.4 })
            );
            bubble.position.set((Math.random() - 0.5) * 40, Math.random() * 30 - 15, (Math.random() - 0.5) * 40);
            bubble.userData.riseSpeed = 0.02 + Math.random() * 0.03;
            bubble.userData.swaySpeed = 0.01;
            bubble.userData.swayPhase = Math.random() * Math.PI * 2;
            bubble.userData.isBubble = true;
            particleGroup.add(bubble);
          }
          break;

        case 'rainy':
        case 'melancholy':
          // é›¨æ»´
          for (let i = 0; i < 200; i++) {
            const drop = new THREE.Mesh(
              new THREE.CylinderGeometry(0.02, 0.02, 0.5 + Math.random() * 0.5, 4),
              new THREE.MeshBasicMaterial({ color: c.accent, transparent:true, opacity:0.5 })
            );
            drop.position.set((Math.random() - 0.5) * 50, Math.random() * 40 - 10, (Math.random() - 0.5) * 50);
            drop.userData.fallSpeed = 0.3 + Math.random() * 0.2;
            drop.userData.isCodeRain = true;
            particleGroup.add(drop);
          }
          break;

        case 'stormy':
          // æš´é£é›¨
          for (let i = 0; i < 250; i++) {
            const drop = new THREE.Mesh(
              new THREE.CylinderGeometry(0.02, 0.02, 0.8, 4),
              new THREE.MeshBasicMaterial({ color:'#a0a0a0', transparent:true, opacity:0.4 })
            );
            drop.position.set((Math.random() - 0.5) * 60, Math.random() * 40 - 10, (Math.random() - 0.5) * 60);
            drop.rotation.z = 0.3;
            drop.userData.fallSpeed = 0.4 + Math.random() * 0.3;
            drop.userData.isCodeRain = true;
            particleGroup.add(drop);
          }
          break;

        case 'kawaii':
          // æ˜Ÿæ˜Ÿå’ŒéŸ³ç¬¦
          for (let i = 0; i < 40; i++) {
            const star = new THREE.Mesh(
              new THREE.CircleGeometry(0.3, i % 3 === 0 ? 5 : 4),
              new THREE.MeshBasicMaterial({
                color: ['#ffb7c5','#b19cd9','#fffacd','#98fb98'][Math.floor(Math.random() * 4)],
                transparent:true, opacity:0.7, side:THREE.DoubleSide
              })
            );
            star.position.set((Math.random() - 0.5) * 30, Math.random() * 20, (Math.random() - 0.5) * 30);
            star.userData.floatSpeed = 0.01 + Math.random() * 0.01;
            star.userData.floatPhase = Math.random() * Math.PI * 2;
            star.userData.isHeart = true;
            particleGroup.add(star);
          }
          break;

        case 'desert':
          // æ²™ç²’
          {
            const sandGeo = new THREE.BufferGeometry();
            const sandCount = 500;
            const sandPos = new Float32Array(sandCount * 3);
            for (let i = 0; i < sandCount; i++) {
              sandPos[i * 3] = (Math.random() - 0.5) * 60;
              sandPos[i * 3 + 1] = Math.random() * 10 - 5;
              sandPos[i * 3 + 2] = (Math.random() - 0.5) * 60;
            }
            sandGeo.setAttribute('position', new THREE.BufferAttribute(sandPos, 3));
            const sand = new THREE.Points(sandGeo, new THREE.PointsMaterial({
              color: c.accent, size:0.1, transparent:true, opacity:0.6
            }));
            sand.userData.isSand = true;
            particleGroup.add(sand);
          }
          break;

        case 'music':
        case 'spotify':
          // éŸ³ç¬¦
          for (let i = 0; i < 30; i++) {
            const note = new THREE.Mesh(
              new THREE.SphereGeometry(0.2, 8, 8),
              new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? c.accent : c.accent2 })
            );
            note.position.set((Math.random() - 0.5) * 30, Math.random() * 20 - 5, (Math.random() - 0.5) * 30);
            note.userData.floatSpeed = 0.02 + Math.random() * 0.02;
            note.userData.floatPhase = Math.random() * Math.PI * 2;
            note.userData.isHeart = true;
            particleGroup.add(note);
          }
          break;

        case 'wedding':
        case 'dawn':
          // é‡‘è‰²èŠ±ç“£
          for (let i = 0; i < 50; i++) {
            const petal = new THREE.Mesh(
              new THREE.CircleGeometry(0.2 + Math.random() * 0.3, 5),
              new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? c.accent : c.accent2,
                transparent:true, opacity:0.6, side:THREE.DoubleSide
              })
            );
            petal.position.set((Math.random() - 0.5) * 35, Math.random() * 25, (Math.random() - 0.5) * 35);
            petal.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            petal.userData.fallSpeed = 0.015 + Math.random() * 0.03;
            petal.userData.swaySpeed = 0.01 + Math.random() * 0.015;
            petal.userData.swayPhase = Math.random() * Math.PI * 2;
            petal.userData.isPetal = true;
            particleGroup.add(petal);
          }
          break;

        case 'terminal':
          // ç»ˆç«¯ä»£ç é›¨ï¼ˆç»¿è‰²æ›´å¯†ï¼‰
          for (let i = 0; i < 120; i++) {
            const cr = new THREE.Mesh(
              new THREE.PlaneGeometry(0.2, 2 + Math.random() * 3),
              new THREE.MeshBasicMaterial({ color: c.accent, transparent:true, opacity:0.3 + Math.random() * 0.4, side:THREE.DoubleSide })
            );
            cr.position.set((Math.random() - 0.5) * 60, Math.random() * 40 - 10, (Math.random() - 0.5) * 40);
            cr.userData.fallSpeed = 0.08 + Math.random() * 0.15;
            cr.userData.isCodeRain = true;
            particleGroup.add(cr);
          }
          break;

        case 'foggy':
          // é›¾æ°”ç²’å­
          {
            const fogGeo = new THREE.BufferGeometry();
            const fogCount = 400;
            const fogPos = new Float32Array(fogCount * 3);
            for (let i = 0; i < fogCount; i++) {
              fogPos[i * 3] = (Math.random() - 0.5) * 60;
              fogPos[i * 3 + 1] = Math.random() * 20 - 10;
              fogPos[i * 3 + 2] = (Math.random() - 0.5) * 60;
            }
            fogGeo.setAttribute('position', new THREE.BufferAttribute(fogPos, 3));
            const fog = new THREE.Points(fogGeo, new THREE.PointsMaterial({
              color:'#c0c0c0', size:1.5, transparent:true, opacity:0.2, blending:THREE.AdditiveBlending
            }));
            fog.userData.isFog = true;
            particleGroup.add(fog);
          }
          break;

        case 'midnight':
          // æ˜Ÿæ˜Ÿå’Œæµæ˜Ÿ
          for (let i = 0; i < 200; i++) {
            const star = new THREE.Mesh(
              new THREE.SphereGeometry(0.05 + Math.random() * 0.1, 4, 4),
              new THREE.MeshBasicMaterial({ color:'#ffffff', transparent:true, opacity:0.5 + Math.random() * 0.5 })
            );
            star.position.set((Math.random() - 0.5) * 80, Math.random() * 30 + 5, (Math.random() - 0.5) * 80);
            star.userData.blinkPhase = Math.random() * Math.PI * 2;
            star.userData.isFirefly = true;
            star.userData.floatPhase = Math.random() * Math.PI * 2;
            star.userData.floatSpeed = 0;
            particleGroup.add(star);
          }
          break;

        case 'weirdcore':
        case 'glitch':
          // æ•°å­—å™ªç‚¹
          for (let i = 0; i < 100; i++) {
            const noise = new THREE.Mesh(
              new THREE.BoxGeometry(0.2 + Math.random() * 0.5, 0.2 + Math.random() * 0.5, 0.1),
              new THREE.MeshBasicMaterial({
                color: ['#ff0000','#00ff00','#0000ff','#ff00ff','#00ffff'][Math.floor(Math.random() * 5)],
                transparent:true, opacity:0.5
              })
            );
            noise.position.set((Math.random() - 0.5) * 40, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30);
            noise.userData.glitchTimer = Math.random() * 100;
            noise.userData.isNoise = true;
            particleGroup.add(noise);
          }
          break;
      }
    }

    // ==================== åº”ç”¨é£æ ¼ ====================
    // æ ¹æ®accentè‰²ç”Ÿæˆæœ‰è‰²å½©å€¾å‘çš„æ·±è‰²èƒŒæ™¯
    function generateStyledBg(accentHex, accent2Hex) {
      const a = new THREE.Color(accentHex);
      const a2 = new THREE.Color(accent2Hex);
      // æ··åˆä¸¤ä¸ªaccentè‰²ï¼Œç„¶åå¤§å¹…é™ä½äº®åº¦ä½†ä¿ç•™è‰²ç›¸
      const mixed = a.clone().lerp(a2, 0.3);
      // ä¿ç•™è‰²ç›¸ï¼Œè®¾ç½®è¾ƒä½ä½†å¯è§çš„äº®åº¦
      const hsl = {};
      mixed.getHSL(hsl);
      // é¥±å’Œåº¦ä¿æŒä¸­ç­‰ï¼Œäº®åº¦è®¾ä¸º 0.06~0.10ï¼ˆæ¯”çº¯é»‘äº®å¾—å¤šï¼Œæœ‰æ˜æ˜¾è‰²å½©ï¼‰
      mixed.setHSL(hsl.h, Math.min(hsl.s * 0.8, 0.6), 0.07 + hsl.s * 0.03);
      return mixed;
    }

    function applyStyle(style, instant = false) {
      currentStyle = style;
      const c = style.colors;

      // æ›´æ–°CSSå˜é‡
      document.documentElement.style.setProperty('--accent', c.accent);
      document.documentElement.style.setProperty('--accent2', c.accent2);

      // ç”Ÿæˆæœ‰é£æ ¼ç‰¹è‰²çš„èƒŒæ™¯è‰²ï¼ˆä¸å†ç”¨å†™æ­»çš„è¿‘é»‘è‰²ï¼‰
      const targetBg = generateStyledBg(c.accent, c.accent2);
      const bgHex = '#' + targetBg.getHexString();
      document.documentElement.style.setProperty('--bg', bgHex);

      if (instant) {
        scene.background.copy(targetBg);
      } else {
        scene.userData.targetBg = targetBg;
      }

      // æ›´æ–°Bloomå¼ºåº¦ï¼ˆé™ä½ä»¥ä¿æŒè£…ç½®æ¸…æ™°ï¼‰
      const bloomIntensity = { SSR: 1.4, SR: 1, R: 0.7, N: 0.5 };
      bloomPass.strength = bloomIntensity[style.rarity] || 0.8;

      // åˆ›å»ºåœºæ™¯å…ƒç´ 
      createGround(style);
      createEnvironment(style);
      createInstallation(style);
      createParticles(style);

      // æ›´æ–°å½“å‰é£æ ¼æ˜¾ç¤º
      const styleNameEl = document.getElementById('current-style');
      styleNameEl.textContent = `${style.icon} ${style.nameCN} Â· ${style.name}`;
      styleNameEl.classList.add('show');
    }

    // ==================== ç›¸æœºè¿é•œç³»ç»Ÿ ====================
    const camState = {
      mode: 'idle',          // idle | pullZoom | reveal | orbit | returning
      time: 0,
      orbitAngle: 0,
      targetPos: new THREE.Vector3(0, 8, 35),
      targetLook: new THREE.Vector3(0, 0, 0),
    };

    const CAM_IDLE = new THREE.Vector3(0, 8, 35);
    const CAM_ZOOM = new THREE.Vector3(0, 5, 20);
    const CAM_ORBIT_DIST = 40;
    const CAM_ORBIT_HEIGHT = 10;

    function updateCamera(t, delta) {
      const speed = 0.03;

      switch (camState.mode) {
        case 'pullZoom':
          // æ¨è¿‘
          camera.position.lerp(CAM_ZOOM, speed * 2);
          camState.time += delta;
          if (camState.time > 0.8) {
            camState.mode = 'reveal';
            camState.time = 0;
          }
          break;
        case 'reveal':
          // ä¿æŒ
          camState.time += delta;
          if (camState.time > 1.5) {
            camState.mode = 'orbit';
            camState.time = 0;
            camState.orbitAngle = Math.atan2(camera.position.x, camera.position.z);
          }
          break;
        case 'orbit':
          // ç¯ç»•
          camState.orbitAngle += delta * 0.15;
          const ox = Math.sin(camState.orbitAngle) * CAM_ORBIT_DIST;
          const oz = Math.cos(camState.orbitAngle) * CAM_ORBIT_DIST;
          const target = new THREE.Vector3(ox, CAM_ORBIT_HEIGHT, oz);
          camera.position.lerp(target, speed);
          camera.lookAt(0, 0, 0);
          break;
        case 'returning':
          // å›åˆ°åˆå§‹
          camera.position.lerp(CAM_IDLE, speed * 2);
          camera.lookAt(0, 0, 0);
          if (camera.position.distanceTo(CAM_IDLE) < 0.5) {
            camState.mode = 'idle';
          }
          break;
        default:
          // idle - å¾®å¾®æµ®åŠ¨
          camera.position.y = 8 + Math.sin(t * 0.3) * 0.5;
          camera.lookAt(0, 0, 0);
      }
    }

    function startPullCamera() {
      camState.mode = 'pullZoom';
      camState.time = 0;
    }

    function startReturnCamera() {
      camState.mode = 'returning';
      camState.time = 0;
    }

    // ==================== è¿‡æ¸¡åŠ¨ç”»ç³»ç»Ÿ ====================
    let transitionState = 'none'; // none | dissolve | build
    let transitionProgress = 0;

    function startTransition() {
      transitionState = 'dissolve';
      transitionProgress = 0;
      // ç¼©å°å½“å‰æ‰€æœ‰è£…ç½®
      installationGroup.children.forEach(child => {
        child.userData.origScale = child.scale.clone();
      });
      particleGroup.children.forEach(child => {
        child.userData.origScale = child.scale.clone();
      });
    }

    function updateTransition(delta) {
      if (transitionState === 'none') return;

      transitionProgress += delta;

      if (transitionState === 'dissolve') {
        // æ—§å…ƒç´ æ”¶ç¼©æ¶ˆæ•£ï¼ˆ0-0.5sï¼‰
        const t = Math.min(transitionProgress / 0.4, 1);
        installationGroup.children.forEach(child => {
          if (child.userData.origScale) {
            const s = 1 - t;
            child.scale.set(
              child.userData.origScale.x * s,
              child.userData.origScale.y * s,
              child.userData.origScale.z * s
            );
            if (child.material) child.material.opacity = Math.max(0, (child.material.opacity || 1) * s);
          }
        });
        if (transitionProgress > 0.4) {
          transitionState = 'build';
          transitionProgress = 0;
        }
      } else if (transitionState === 'build') {
        // æ–°å…ƒç´ ä»å°åˆ°å¤§å±•å¼€ï¼ˆ0-0.6sï¼‰
        const t = Math.min(transitionProgress / 0.6, 1);
        const eased = 1 - Math.pow(1 - t, 3); // ease-out cubic
        installationGroup.children.forEach(child => {
          child.scale.setScalar(eased);
        });
        if (transitionProgress > 0.6) {
          transitionState = 'none';
          // æ¢å¤æ­£å¸¸scale
          installationGroup.children.forEach(child => {
            child.scale.set(1, 1, 1);
            delete child.userData.origScale;
          });
        }
      }
    }

    // ==================== åŠ¨ç”»å¾ªç¯ ====================
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      const delta = clock.getDelta();

      // ç›¸æœºè¿é•œ
      updateCamera(t, delta);

      // è¿‡æ¸¡åŠ¨ç”»
      updateTransition(delta);

      // Shader uniform æ›´æ–°
      updateShaderTime(installationGroup, t);

      // èƒŒæ™¯è¿‡æ¸¡
      if (scene.userData.targetBg) {
        scene.background.lerp(scene.userData.targetBg, 0.03);
      }

      // ç²’å­åŠ¨ç”»
      particleGroup.children.forEach(child => {
        if (child.userData.isBaseParticle) {
          child.rotation.y = t * 0.02;
        }
        if (child.userData.isPetal || child.userData.isSnow) {
          child.position.y -= child.userData.fallSpeed;
          // æ›´è‡ªç„¶çš„æ‘‡æ‘†ï¼ˆå¤šé¢‘æ­£å¼¦å åŠ ï¼‰
          const sw = child.userData.swaySpeed;
          const sp = child.userData.swayPhase;
          child.position.x += Math.sin(t * 0.8 + sp) * sw + Math.sin(t * 1.3 + sp * 2) * sw * 0.3;
          child.position.z += Math.cos(t * 0.6 + sp * 1.5) * sw * 0.5;
          child.rotation.x += 0.008 + Math.sin(t + sp) * 0.005;
          child.rotation.y += 0.012;
          child.rotation.z += Math.cos(t * 0.5 + sp) * 0.003;
          if (child.position.y < -15) child.position.y = 25;
        }
        if (child.userData.isCodeRain) {
          child.position.y -= child.userData.fallSpeed;
          if (child.position.y < -15) child.position.y = 30;
        }
        if (child.userData.isHeart) {
          child.position.y += Math.sin(t * 2 + child.userData.floatPhase) * 0.02;
          child.position.x += Math.cos(t * 0.8 + child.userData.floatPhase) * 0.005;
        }
        if (child.userData.isFirefly) {
          child.position.y += Math.sin(t + child.userData.floatPhase) * 0.01;
          child.position.x += Math.cos(t * 0.5 + child.userData.floatPhase) * 0.01;
          child.material.opacity = 0.5 + Math.sin(t * 3 + child.userData.blinkPhase) * 0.5;
        }
        if (child.userData.isBubble) {
          child.position.y += child.userData.riseSpeed;
          child.position.x += Math.sin(t + child.userData.swayPhase) * child.userData.swaySpeed;
          if (child.position.y > 20) child.position.y = -15;
        }
        if (child.userData.isNoise) {
          child.userData.glitchTimer += delta;
          if (Math.random() < 0.03) {
            child.position.set((Math.random() - 0.5) * 40, (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 30);
            child.material.opacity = Math.random() * 0.5;
          }
        }
        if (child.userData.isSand) {
          child.rotation.y = t * 0.01;
          const sandPos = child.geometry.attributes.position.array;
          for (let i = 0; i < sandPos.length; i += 3) {
            sandPos[i] += Math.sin(t + i) * 0.01;
            sandPos[i + 1] += 0.005;
            if (sandPos[i + 1] > 5) sandPos[i + 1] = -5;
          }
          child.geometry.attributes.position.needsUpdate = true;
        }
        if (child.userData.isFog) {
          child.rotation.y = t * 0.005;
        }
      });

      // è£…ç½®åŠ¨ç”»ï¼ˆå¸¦ç¼“åŠ¨ï¼‰
      installationGroup.children.forEach(child => {
        if (child.userData.rotSpeed) {
          // å‘¼å¸å¼æ—‹è½¬é€Ÿåº¦ï¼ˆåŠ å‡é€Ÿï¼‰
          const breathFactor = 0.8 + Ease.breathe(t, 0.5) * 0.4;
          const speed = child.userData.rotSpeed * breathFactor;
          if (child.userData.rotAxis === 'x') child.rotation.x += speed;
          else if (child.userData.rotAxis === 'z') child.rotation.z += speed;
          else child.rotation.y += speed;
        }
        if (child.userData.isWave && child.geometry) {
          const pos = child.geometry.attributes.position;
          for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i);
            const z = Math.sin(x * 0.1 + t + child.userData.wavePhase) * 2;
            pos.setZ(i, z);
          }
          pos.needsUpdate = true;
        }
        if (child.userData.floatPhase !== undefined && child.userData.floatSpeed) {
          // æŸ”å’Œå¼¹æ€§æµ®åŠ¨
          const phase = child.userData.floatPhase;
          const floatY = Math.sin(t * 0.8 + phase) * 1.2 + Math.sin(t * 1.3 + phase * 2) * 0.4;
          const baseY = child.userData.baseY !== undefined ? child.userData.baseY : (child.userData._origY ?? child.position.y);
          if (child.userData._origY === undefined) child.userData._origY = child.position.y;
          child.position.y = baseY + floatY;
          // è½»å¾®æ‘‡æ‘†
          child.rotation.z = Math.sin(t * 0.5 + phase) * 0.05;
        }
        if (child.userData.isBounce) {
          // æœå†»å¼¹è·³
          const bounce = Ease.breathe(t * 2 + child.userData.floatPhase, 1);
          child.position.y += Math.sin(t * 2 + child.userData.floatPhase) * 0.03;
          child.scale.x = 1 + Math.sin(t * 2.5 + child.userData.floatPhase) * 0.08;
          child.scale.y = 1 - Math.sin(t * 2.5 + child.userData.floatPhase) * 0.06;
          child.scale.z = 1 + Math.sin(t * 2.5 + child.userData.floatPhase + 1) * 0.06;
        }
        if (child.userData.isGlitch) {
          child.children.forEach((gc, i) => {
            gc.position.x = (i - 1) * 0.5 + Math.sin(t * 10 + i) * (Math.random() > 0.95 ? 2 : 0);
            gc.position.y = Math.sin(t * 8 + i * 2) * (Math.random() > 0.95 ? 1 : 0);
          });
          child.rotation.y = t * 0.2;
        }
        if (child.userData.isData && child.geometry) {
          const pos = child.geometry.attributes.position.array;
          for (let i = 0; i < pos.length; i += 3) {
            pos[i + 1] += 0.02;
            if (pos[i + 1] > 6) pos[i + 1] = -6;
          }
          child.geometry.attributes.position.needsUpdate = true;
        }
        if (child.userData.isSmoke && child.geometry) {
          const pos = child.geometry.attributes.position.array;
          for (let i = 0; i < pos.length; i += 3) {
            pos[i + 1] += 0.01;
            pos[i] += (Math.random() - 0.5) * 0.02;
            if (pos[i + 1] > 15) { pos[i + 1] = -2; pos[i] = (Math.random() - 0.5) * 3; }
          }
          child.geometry.attributes.position.needsUpdate = true;
        }
        if (child.userData.isBar) {
          // éŸ³æ³¢å¾‹åŠ¨ï¼ˆå¤šé¢‘å åŠ ï¼‰
          const p = child.userData.barPhase;
          const wave = Math.abs(Math.sin(t * 3 + p)) * 0.4
                     + Math.abs(Math.sin(t * 5.3 + p * 1.7)) * 0.3
                     + Math.abs(Math.sin(t * 7.1 + p * 0.5)) * 0.2;
          const newH = child.userData.baseHeight * (0.15 + wave * 0.85);
          child.scale.y = newH / child.userData.baseHeight;
        }
        if (child.userData.isJellyfish) {
          // æœ‰æœºæ°´æ¯è¿åŠ¨
          const jPhase = child.userData.floatPhase;
          child.position.y += Math.sin(t * 0.4 + jPhase) * 0.015;
          child.position.x += Math.cos(t * 0.2 + jPhase) * 0.008;
          child.position.z += Math.sin(t * 0.15 + jPhase * 2) * 0.005;
          // æ°´æ¯ä¼ç›–è„‰å†²
          const pulse = 1 + Math.sin(t * 2 + jPhase) * 0.15;
          if (child.children[0]) {
            child.children[0].scale.set(pulse, 0.8 + (1 - pulse) * 0.5, pulse);
          }
          child.children.forEach(tent => {
            if (tent.userData.tentaclePhase !== undefined) {
              tent.rotation.x = Math.sin(t * 1.5 + tent.userData.tentaclePhase) * 0.3;
              tent.rotation.z = Math.cos(t * 1.2 + tent.userData.tentaclePhase) * 0.1;
            }
          });
        }
        if (child.userData.isEye) {
          const lookX = Math.sin(t + child.userData.lookPhase) * 0.3;
          const lookY = Math.cos(t * 0.7 + child.userData.lookPhase) * 0.3;
          if (child.children[1]) {
            child.children[1].position.x = lookX;
            child.children[1].position.y = lookY;
          }
        }
        if (child.userData.isFlame && child.material) {
          child.scale.y = 1 + Math.sin(t * 10) * 0.3;
          child.material.opacity = 0.7 + Math.sin(t * 8) * 0.3;
        }
        if (child.userData.isMetal && child.geometry) {
          const pos = child.geometry.attributes.position;
          for (let i = 0; i < pos.count; i++) {
            const origY = pos.getY(i);
            pos.setY(i, origY + Math.sin(t * 2 + pos.getX(i)) * 0.003);
          }
          pos.needsUpdate = true;
        }
        // è½¨é“è¿åŠ¨ï¼ˆæ¸å˜æµä½“çƒç­‰ï¼‰
        if (child.userData.isOrbit) {
          const p = child.userData.floatPhase;
          const r = child.userData.orbitRadius;
          const s = child.userData.orbitSpeed;
          child.position.x = Math.cos(t * s + p) * r;
          child.position.z = Math.sin(t * s + p) * r;
          child.position.y = Math.sin(t * s * 2 + p) * 2;
          // ç¼“æ…¢è„‰å†²ç¼©æ”¾
          const sc = 1 + Ease.breathe(t + p, 0.5) * 0.15;
          child.scale.setScalar(sc);
        }
        // å­å…ƒç´ åŠ¨ç”»
        if (child.children && child.children.length > 0) {
          child.children.forEach(subChild => {
            if (subChild.userData.rotSpeed) {
              subChild.rotation.y += subChild.userData.rotSpeed;
              subChild.rotation.x += subChild.userData.rotSpeed * 0.5;
            }
          });
        }
      });

      // ç¯å¢ƒåŠ¨ç”»
      environmentGroup.children.forEach(child => {
        if (child.userData.isAurora && child.geometry) {
          const pos = child.geometry.attributes.position;
          for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i);
            const wave = Math.sin(x * 0.05 + t + child.userData.phase) * 2;
            pos.setZ(i, wave);
          }
          pos.needsUpdate = true;
        }
        if (child.userData.isLightning) {
          // éšæœºé—ªç”µ
          if (Math.random() < 0.005) {
            child.intensity = 3;
            setTimeout(() => { child.intensity = 0; }, 100);
            setTimeout(() => { child.intensity = 2; }, 200);
            setTimeout(() => { child.intensity = 0; }, 300);
          }
        }
      });

      composer.render();
    }

    // åˆå§‹åŒ–é»˜è®¤é£æ ¼
    applyStyle(STYLES[0], true);
    animate();

    // ==================== UIäº¤äº’ ====================
    const pullBtn = document.getElementById('pull-btn');
    const cardPanel = document.getElementById('card-panel');
    const card = document.getElementById('card');
    const continueBtn = document.getElementById('continue-btn');
    const flash = document.getElementById('flash');
    const hint = document.getElementById('hint');

    function getRandomStyle() {
      const weights = { SSR: 3, SR: 15, R: 45, N: 37 };
      const pool = [];
      STYLES.forEach(s => {
        const w = weights[s.rarity] || 20;
        for (let i = 0; i < w; i++) pool.push(s);
      });
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function showCard(style) {
      // æ›´æ–°å¡ç‰Œå†…å®¹
      document.getElementById('card-rarity').textContent = style.rarity;
      document.getElementById('card-rarity').className = 'card-rarity ' + style.rarity.toLowerCase();
      document.getElementById('card-icon').textContent = style.icon;
      document.getElementById('card-name').textContent = style.name;
      document.getElementById('card-name-cn').textContent = style.nameCN;
      document.getElementById('card-desc').textContent = style.desc;
      document.getElementById('card-tags').innerHTML = style.tags.map(t => `<span class="card-tag">${t}</span>`).join('');

      const cardFront = document.getElementById('card-front');
      cardFront.className = 'card-face card-front ' + style.rarity.toLowerCase();

      // é‡ç½®å¡ç‰ŒçŠ¶æ€
      card.classList.remove('flipped');

      // æ˜¾ç¤ºå¡ç‰Œé¢æ¿
      cardPanel.classList.add('show');

      // å»¶è¿Ÿç¿»è½¬
      setTimeout(() => {
        card.classList.add('flipped');
        // æ˜¾ç¤ºç»§ç»­æŒ‰é’®
        setTimeout(() => {
          continueBtn.classList.add('show');
        }, 800);
      }, 300);
    }

    function pull() {
      if (isPulling) return;
      isPulling = true;

      hint.classList.add('hidden');
      pullBtn.classList.add('hidden');
      document.getElementById('current-style').classList.remove('show');

      // 1. ç›¸æœºæ¨è¿‘
      startPullCamera();

      // 2. æ—§åœºæ™¯æ¶ˆæ•£
      startTransition();

      // 3. å»¶è¿Ÿååˆ›å»ºæ–°åœºæ™¯
      const style = getRandomStyle();
      setTimeout(() => {
        // é—ªå…‰æ•ˆæœ
        flash.className = 'show ' + style.rarity.toLowerCase();
        setTimeout(() => flash.className = '', 400);

        // åº”ç”¨æ–°é£æ ¼ï¼ˆæ­¤æ—¶ transitionState å·²è¿›å…¥ build é˜¶æ®µï¼‰
        applyStyle(style);
      }, 500);

      // 4. æ˜¾ç¤ºå¡ç‰Œ
      setTimeout(() => showCard(style), 1200);
    }

    function confirmPull() {
      pullCount++;
      document.getElementById('pull-count').textContent = pullCount;

      // æ·»åŠ åˆ°æ”¶è—
      if (!collection.find(s => s.id === currentStyle.id)) {
        collection.push(currentStyle);
        updateCollection();
      }

      // éšè—å¡ç‰Œ
      cardPanel.classList.remove('show');
      continueBtn.classList.remove('show');

      // ç›¸æœºè¿”å›
      startReturnCamera();

      // æ˜¾ç¤ºæŠ½å–æŒ‰é’®
      setTimeout(() => {
        pullBtn.classList.remove('hidden');
        isPulling = false;
      }, 500);
    }

    function updateCollection() {
      const el = document.getElementById('collection');
      el.innerHTML = collection.map(s => `
        <div class="collection-item ${s.rarity.toLowerCase()}"
             onclick="viewStyle('${s.id}')"
             title="${s.nameCN}"
             style="border-color:${s.colors.accent};">
          ${s.icon}
        </div>
      `).join('');
      document.getElementById('collected-count').textContent = collection.length;
    }

    // æŸ¥çœ‹æ”¶è—çš„é£æ ¼
    window.viewStyle = (id) => {
      const style = STYLES.find(s => s.id === id);
      if (style && !isPulling) {
        applyStyle(style);
        showCard(style);
        pullBtn.classList.add('hidden');
      }
    };

    pullBtn.addEventListener('click', pull);
    continueBtn.addEventListener('click', confirmPull);

    // çª—å£å¤§å°è°ƒæ•´
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
    });

    // ==================== URLå‚æ•°é¢„è§ˆ ====================
    function checkUrlPreview() {
      const hash = location.hash;
      if (hash.startsWith('#preview=')) {
        const id = hash.replace('#preview=', '');
        const style = STYLES.find(s => s.id === id);
        if (style) {
          hint.classList.add('hidden');
          applyStyle(style);
          showCard(style);
          pullBtn.classList.add('hidden');
        }
      }
    }
    checkUrlPreview();
    window.addEventListener('hashchange', checkUrlPreview);
  </script>
</body>
</html>
